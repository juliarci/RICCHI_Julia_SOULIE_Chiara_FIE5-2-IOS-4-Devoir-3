---
title: "FIE5-2-IOS-4-Devoir-3"
author: "Adrien Wartelle"
date: "2026-01-11"
output: html_notebook # html_document
---

# Etude de cas sur l’analyse et la mesure de performance des Flux de Patients

## Introduction

Ce travail porte sur l'analyse des flux de patients sur un plateau mutualisé de consultations externes d'un hôpital. L'objectif est de réaliser un diagnostic objectif de la performance organisationnelle du service d'urologie en s'appuyant sur les méthodes et outils d'analyse de flux vus précédemment ainsi que sur le langage R à travers l’environnement de RStudio. La figure ci-dessous illustre les principaux flux ainsi que le Plan du plateau de consultations (voir fichiers PlanConsultations.pdf et ZoomURO.pdf consultables à partir <http://bit.ly/PlansCHUTlse>)

<!--<img src="illustrations/PlanUro.png" alt="Plan du plateau de consultations" width="600"/>-->

![Plan du plateau de consultations](illustrations/PlanUro.png "Plan du plateau de consultations") Afin de collecter des données sur les parcours suivis, les patients qui se sont présentés le 12/11/2015 ont été équipés d’une étiquette électronique (type RFID) qui a permis de tracer leurs parcours dans le plateau de consultation. Les données collectées ont été fusionnées avec les données des outils de gestion des dossiers administratifs et médicaux utilisés par les personnels. L'ensemble est disponible sous la forme d’un fichier log, illustré par le tableau suivant (voir annexe LogPatientUROseul_12112015.xlsx consultable à partir <http://bit.ly/logPatients>).

<!--<img src="illustrations/TableauLogPatients.png" alt="Vue du tableau de données de log patient" width="600"/>-->

![*Vue du tableau de données de log patient*](illustrations/TableauLogPatients.png "Vue du tableau de données de log patient")

Les différentes de ce tableau de données sont :

-   *ID* (Col A) : Identifiant du patient

-   *Timestamp start* (Col B) : horodatage entrée de zone ou salle

-   *Timestamp end* (Col C) : horodatage sortie de zone ou salle

-   *Activity_MACRO* (Col D) : Type d'activité

-   *Activity_DETAILS* (Col E) : Activité suivie et indice salle (i)

-   *Ress.Humaines* (Col F) : Ressources humaines administratives ou soignantes intervenant dans l'activité

-   *distance parcourues* (Col G) : Distance parcourue cumulée

-   *début/fin opX* (Col H à O) : horodatage début/fin de chaque opération de prise en charge par une ressource administrative ou soignante (maxi 4 opérations par activité).

## **Devoir 3 - Travail demandé** : Modélisation de file d'attente

Ce travail, qui peut-être effectué en binôme, est à rendre pour le **01/03/2026** au format Rmd ou R (+pdf si besoin) avec pour titre "NOM_Prenom_FIA5-2-IOS-4-Devoir-3.\*"

Ce troisième devoir va se focaliser sur la modélisation du service d'accueil. Après une extraction générale des modèles, il vaut sera demandé d'étudier un ensemble de modèle en les comparant quantitativement à la réalité et entre eux sur la base des mesures empiriques et des formules données par la théorie des files d'attente.

```{r include=FALSE}
library(tidyverse)
library(data.table)
library(readxl)

load("local_data/trace_example_1.RData")
load("local_data/trace_example_final.RData")
devoir3_data_accueil <- read_csv2("local_data/devoir3_data_accueil.csv")
```

### Question 1) Extraction des paramètres (/5)

L'objectif de cette question est d'extraire les temps d'arrivées, de départ de file et de départ de l'accueil de chaque patient et d'en extraire les paramètres empiriques de taux d'arrivée et de service.

1.1) Dans un premier temps nous allons reformater les données afin de faciliter l'extraction en extrayant pour chaque patient :

-   $td$ : La datetime de départ du service d’accueil

-   $ta$ : La datetime d'arrivée au service d’accueil

-   $tdq$ : La datetime de sortie de file. **Attention**, on ne souhaite pas la datetime de sortie physique de la salle d'attente mais plutôt la datetime à partir de laquelle le bureau qui le prend en charge devient disponible pour obtenir des temps de process qui soit effectif (notion de *Effective Process Time*). On applique pour chaque bureau et chaque patient.

-   $S=tdq - td$

    -   $tdq_m = max(ta_m,td_{m-1})$ (avec $m > 1$ correspondant aux indices de patient dans l'ordre de **service** du bureau concerné, pour $m=1$ on prendra $tdq_1 = ta_1$)

```{r}
library(dplyr)
library(lubridate)
library(readxl)

# Charger le fichier Excel
df <- read_excel("Log_Patient_URO_12112015.xlsx")

# Convertir les timestamps en POSIXct si nécessaire
df <- df %>%
  mutate(
    `Timestamp start` = as.POSIXct(`Timestamp start`, format = "%d/%m/%Y %H:%M:%S"),
    `Timestamp end` = as.POSIXct(`Timestamp end`, format = "%d/%m/%Y %H:%M:%S")
  )

# Table de correspondance des noms
place_table <- tibble(
  Activity_DETAILS = c("Entrée des Consultations",
    "ACCUEIL.Bureau_AccueilPRIO(1)","ACCUEIL.Bureau_Accueil(1)",
    "ACCUEIL.Bureau_Accueil(2)","ACCUEIL.Bureau_Accueil(3)",
    "ACCUEIL.S_Attente_Accueil(1)"),
  place = c("Entree_Generale","Accueil_Prio_1","Accueil_General_1",
            "Accueil_General_2","Accueil_General_3","Accueil_Attente")
)

# Extraire ta (arrivée à l'accueil = première entrée en salle d'attente ou bureau)
ta_data <- df %>%
  filter(grepl("ACCUEIL", Activity_DETAILS)) %>%
  group_by(ID) %>%
  summarise(ta = min(`Timestamp start`, na.rm = TRUE)) %>%
  ungroup()

# Extraire td (départ de l'accueil = fin de passage au bureau)
td_data <- df %>%
  filter(grepl("ACCUEIL.Bureau", Activity_DETAILS)) %>%
  group_by(ID) %>%
  summarise(
    td = max(`Timestamp end`, na.rm = TRUE),
    CURRENT_LOCATION = last(Activity_DETAILS)
  ) %>%
  ungroup()

# Fusionner ta et td
accueil <- td_data %>%
  left_join(ta_data, by = "ID") %>%
  arrange(ta) %>%
  filter(!is.na(ta) & !is.na(td))

# Remplacer les noms de lieux
accueil <- accueil %>%
  left_join(place_table, by = c("CURRENT_LOCATION" = "Activity_DETAILS")) %>%
  mutate(CURRENT_LOCATION = ifelse(is.na(place), CURRENT_LOCATION, place)) %>%
  select(-place)

# Calculer tdq par bureau (CURRENT_LOCATION)
# Pour chaque bureau, on applique la formule tdq_m = max(ta_m, td_{m-1})
accueil <- accueil %>%
  group_by(CURRENT_LOCATION) %>%
  arrange(ta) %>%
  mutate(
    lag_td = lag(td),
    tdq = if_else(row_number() == 1, ta, pmax(ta, lag_td, na.rm = TRUE))
  ) %>%
  ungroup()

# Calculer S = tdq - td (attention : S = td - tdq pour le temps d'attente)
# Selon la formule, S semble être le temps de service effectif
accueil <- accueil %>%
  mutate(S = as.numeric(difftime(td, tdq, units = "secs")))

# Sélectionner et réorganiser les colonnes
accueil <- accueil %>%
  select(CURRENT_LOCATION, ID, td, ta, lag_td, tdq, S) %>%
  arrange(CURRENT_LOCATION, ta) 

# Afficher le résultat
accueil

```

**Résultat :**

On voit que le tableau final est identique au tableau à obtenir.

Vous devriez obtenir le tableau suivant :

```{r}
devoir3_data_accueil
```

1.2) Calculez les indicateurs suivant :

Définissons tout d'abord les paramètres de base :

```{r answer 1.2}
library(dplyr)
library(lubridate)

# Définir les tranches horaires
accueil <- accueil %>%
  mutate(
    heure = hour(ta) + minute(ta)/60,
    tranche = case_when(
      heure >= 8 & heure < 11.333 ~ "[8h;11h20]",
      heure >= 11.333 & heure < 14.667 ~ "[11h20;14h40]",
      heure >= 14.667 & heure < 18 ~ "[14h40;18h00]",
      TRUE ~ "Hors_plage"
    ),
    type_bureau = if_else(CURRENT_LOCATION == "Accueil_Prio_1", "Prio", "Autres")
  )

# Durée totale en heures (8h à 18h = 10h)
duree_totale <- 10

# Durée par tranche (10h / 3 = 3.333h)
duree_tranche <- 10/3
```

-   $\lambda$ : Taux d'arrivée moyen global sur la journée (de 8h à 18h)

    ```{r answer 1.2.2}

    lambda_global <- nrow(accueil) / duree_totale

    lambda_global
    ```

-   $\lambda_{Prio}$ : Taux d'arrivée moyen pour le bureau d'accueil prioritaire

    ```{r answer 1.2.3}

    lambda_Prio <- sum(accueil$type_bureau == "Prio") / duree_totale
    lambda_Prio
    ```

-   $\lambda_{Autres}$ : Taux d'arrivée moyen pour les 3 autres bureaux

    ```{r answer 1.2.4}

    lambda_Autres <- sum(accueil$type_bureau == "Autres") / duree_totale
    lambda_Autres
    ```

-   $\lambda_{[8h;11h20]}, \lambda_{[11h20;14h40]},\lambda_{[14h40;18h00]}$ : Taux d'arrivée sur 3 les tranches des 10h d'activité

    ```{r answer 1.2.5}
    lambda_tranches <- accueil %>%
      filter(tranche != "Hors_plage") %>%
      group_by(tranche) %>%
      summarise(lambda = n() / duree_tranche, .groups = "drop")

    lambda_8h_11h20    <- lambda_tranches %>% filter(tranche == "[8h;11h20]")    %>% pull(lambda)
    lambda_11h20_14h40 <- lambda_tranches %>% filter(tranche == "[11h20;14h40]") %>% pull(lambda)
    lambda_14h40_18h   <- lambda_tranches %>% filter(tranche == "[14h40;18h00]") %>% pull(lambda)

    # Taux d'arrivée par tranche ET type de bureau
    lambda_tranches_bureau <- accueil %>%
      filter(tranche != "Hors_plage") %>%
      mutate(
        tranche = factor(
          tranche,
          levels = c("[8h;11h20]", "[11h20;14h40]", "[14h40;18h00]")
        )
      ) %>%
      group_by(tranche, type_bureau) %>%
      summarise(
        lambda = n() / duree_tranche,
        .groups = "drop"
      ) %>%
      arrange(tranche)


    lambda_tranches_bureau
    ```

-   $\lambda_{[8h;11h20],Prio}, \lambda_{[11h20;14h40],Prio},\lambda_{[14h40;18h00],Prio}$ : Taux d'arrivée sur 3 les tranches des 10h d'activité pour le bureau d'accueil prioritaire

    ```{r answer 1.2.6}
    lambda_8h_11h20_Prio <- lambda_tranches_bureau %>% 
      filter(tranche == "[8h;11h20]", type_bureau == "Prio") %>% pull(lambda)
    lambda_11h20_14h40_Prio <- lambda_tranches_bureau %>% 
      filter(tranche == "[11h20;14h40]", type_bureau == "Prio") %>% pull(lambda)
    lambda_14h40_18h_Prio <- lambda_tranches_bureau %>% 
      filter(tranche == "[14h40;18h00]", type_bureau == "Prio") %>% pull(lambda)

    # Gestion des valeurs manquantes (tranches sans patients)
    lambda_8h_11h20_Prio <- ifelse(length(lambda_8h_11h20_Prio) == 0, 0, lambda_8h_11h20_Prio)
    lambda_11h20_14h40_Prio <- ifelse(length(lambda_11h20_14h40_Prio) == 0, 0, lambda_11h20_14h40_Prio)
    lambda_14h40_18h_Prio <- ifelse(length(lambda_14h40_18h_Prio) == 0, 0, lambda_14h40_18h_Prio)

    cat("Lamda[8h;11h20]Prio : ",lambda_8h_11h20_Prio, "\n")
    cat("Lamda[11h20;14h40]Prio : ",lambda_11h20_14h40_Prio, "\n")
    cat("Lamda[14h40;18h00]Prio : ",lambda_14h40_18h_Prio)
    ```

-   $\lambda_{[8h;11h20],Autres}, \lambda_{[11h20;14h40],Autres},\lambda_{[14h40;18h00],Autres}$ : Taux d'arrivée sur 3 les tranches des 10h d'activité pour les 3 autres bureaux

    ```{r answer 1.2.7}
    lambda_8h_11h20_Autres <- lambda_tranches_bureau %>% 
      filter(tranche == "[8h;11h20]", type_bureau == "Autres") %>% pull(lambda)
    lambda_11h20_14h40_Autres <- lambda_tranches_bureau %>% 
      filter(tranche == "[11h20;14h40]", type_bureau == "Autres") %>% pull(lambda)
    lambda_14h40_18h_Autres <- lambda_tranches_bureau %>% 
      filter(tranche == "[14h40;18h00]", type_bureau == "Autres") %>% pull(lambda)

    lambda_8h_11h20_Autres <- ifelse(length(lambda_8h_11h20_Autres) == 0, 0, lambda_8h_11h20_Autres)
    lambda_11h20_14h40_Autres <- ifelse(length(lambda_11h20_14h40_Autres) == 0, 0, lambda_11h20_14h40_Autres)
    lambda_14h40_18h_Autres <- ifelse(length(lambda_14h40_18h_Autres) == 0, 0, lambda_14h40_18h_Autres)

    cat("Lamda[8h;11h20]Autres : ",lambda_8h_11h20_Autres, "\n")
    cat("Lamda[11h20;14h40]Autres : ",lambda_11h20_14h40_Autres, "\n")
    cat("Lamda[14h40;18h00]Autres : ",lambda_14h40_18h_Autres)
    ```

-   $\mu = \frac{1}{\bar{S}}$ : Taux de service moyen

    ```{r answer 1.2.8}
    mu_global <- 3600 / S_mean
    cat("mu = ",mu_global, " clients/heures")
    ```

-   $\mu_{Prio} = \frac{1}{\bar{S_{Prio}}}$ : Taux de service moyen pour le bureau d'accueil prioritaire

    ```{r answer 1.2.9}
    S_mean_Prio <- mean(accueil$S[accueil$type_bureau == "Prio"], na.rm = TRUE)
    mu_Prio <- 3600 / S_mean_Prio
    cat("muPrio = ",mu_Prio, " clients/heures")
    ```

-   $\mu_{Autres} = \frac{1}{\bar{S_{Prio}}}$ : Taux de service moyen pour les 3 autres bureaux

    ```{r answer 1.2.10}
    S_mean_Autres <- mean(accueil$S[accueil$type_bureau == "Autres"], na.rm = TRUE)
    mu_Autres <- 3600 / S_mean_Autres
    cat("muAutres = ",mu_Autres, " clients/heures")
    ```

-   $cv_S$ : Coefficient de variation du temps de service général

    ```{r answer 1.2.11}
    S_sd <- sd(accueil$S, na.rm = TRUE)
    cv_S <- S_sd / S_mean
    cat("cv_S = ", cv_S)
    ```

-   $cv_{S_{Prio}}$ : Coefficient de variation du temps de service général pour le bureau d'accueil prioritaire

    ```{r answer 1.2.12}
    S_sd_Prio <- sd(accueil$S[accueil$type_bureau == "Prio"], na.rm = TRUE)
    cv_S_Prio <- S_sd_Prio / S_mean_Prio
    cat("cv_S_Prio = ", cv_S_Prio)
    ```

-   $cv_{S_{Autres}}$ : Coefficient de variation du temps de service général pour les 3 autres bureaux

    ```{r answer 1.2.13}
    S_sd_Autres <- sd(accueil$S[accueil$type_bureau == "Autres"], na.rm = TRUE)
    cv_S_Autres <- S_sd_Autres / S_mean_Autres
    cat("cv_S_Autres = ", cv_S_Autres)
    ```

-   $W,W_{Prio},W_{Autres},W_q,W_{q,Prio},W_{q,Autres}...$ : Indicateurs de temps d'attente (aussi pour chacune des 3 tranches de journée)

    ```{r answer 1.2.14}
    # Calculer les temps d'attente empiriques
    accueil <- accueil %>%
      mutate(
        W_q = as.numeric(difftime(tdq, ta, units = "secs")), 
        W = as.numeric(difftime(td, ta, units = "secs"))     
      )

    # W et W_q globaux (en secondes)
    W_global <- mean(accueil$W, na.rm = TRUE)
    W_q_global <- mean(accueil$W_q, na.rm = TRUE)

    # Par type de bureau
    W_Prio <- mean(accueil$W[accueil$type_bureau == "Prio"], na.rm = TRUE)
    W_q_Prio <- mean(accueil$W_q[accueil$type_bureau == "Prio"], na.rm = TRUE)

    W_Autres <- mean(accueil$W[accueil$type_bureau == "Autres"], na.rm = TRUE)
    W_q_Autres <- mean(accueil$W_q[accueil$type_bureau == "Autres"], na.rm = TRUE)

    # Par tranche horaire
    W_tranches <- accueil %>%
      filter(tranche != "Hors_plage") %>%
      group_by(tranche) %>%
      summarise(
        W = mean(W, na.rm = TRUE),
        W_q = mean(W_q, na.rm = TRUE),
        .groups = "drop"
      )

    # Par tranche ET type de bureau
    W_tranches_bureau <- accueil %>%
      filter(tranche != "Hors_plage") %>%
      mutate(
        tranche = factor(
          tranche,
          levels = c("[8h;11h20]", "[11h20;14h40]", "[14h40;18h00]")
        )
      ) %>%
      group_by(tranche, type_bureau) %>%
      summarise(
        W = mean(W, na.rm = TRUE),
        W_q = mean(W_q, na.rm = TRUE),
        .groups = "drop"
      )
    W_tranches_bureau
    ```

-   $L,L_{Prio},L_{Autres},L_q,L_{q,Prio},L_{q,Autres}...$ : Indicateurs de niveau d'occupation moyen entre 8h et 18h (aussi pour chacune des 3 tranches de journée)

    ```{r answer 1.2.15}
    # L = λ * W (Loi de Little)

    # L et L_q globaux
    L_global <- lambda_global * (W_global / 3600) 
    L_q_global <- lambda_global * (W_q_global / 3600)

    # Par type de bureau
    L_Prio <- lambda_Prio * (W_Prio / 3600)
    L_q_Prio <- lambda_Prio * (W_q_Prio / 3600)

    L_Autres <- lambda_Autres * (W_Autres / 3600)
    L_q_Autres <- lambda_Autres * (W_q_Autres / 3600)

    # Par tranche horaire
    L_tranches <- lambda_tranches %>%
      left_join(W_tranches, by = "tranche") %>%
      mutate(
        L = lambda * (W / 3600),
        L_q = lambda * (W_q / 3600)
      )

    # Par tranche ET type de bureau
    L_tranches_bureau <- lambda_tranches_bureau %>%
      left_join(W_tranches_bureau, by = c("tranche", "type_bureau")) %>%
      mutate(
        L = lambda * (W / 3600),
        L_q = lambda * (W_q / 3600)
      )

    L_tranches_bureau
    ```

1.3) Analyse et discussion : Approfondissez l'EDA du devoir 1 sur la partie Accueil. Des plots temporels sur les indicateurs peuvent vous aider.

```{r answer 1.3.1}
library(ggplot2)
library(lubridate)

# Assurons-nous que ta et td sont en POSIXct
accueil <- accueil %>%
  mutate(
    ta = as.POSIXct(ta, tz = "Europe/Paris"),
    td = as.POSIXct(td, tz = "Europe/Paris")
  )

ggplot(accueil, aes(y = factor(ID))) +
  geom_segment(aes(x = ta, xend = td, yend = factor(ID), color = type_bureau), size = 3) +
  labs(title = "Présence des patients dans le système",
       x = "Heure",
       y = "ID du patient",
       color = "Type de bureau") +
  theme_minimal() +
  theme(axis.text.y = element_blank())

```

**Analyse :**

Sur ce graphique voit qu'on a un nombre moindre de patients prioritaires et que globalement leurs temps d'attente sont plus courts que les patients des autres bureaux. On voit également qu'il y a des périodes avec un taux d'affluence plus élevé comme aux alentours de 12h par exemple où de nombreux patients sont présents.

```{r answer 1.3.2}
ggplot(accueil %>% arrange(desc(W)), aes(x = factor(ID), y = W, fill = type_bureau)) +
  geom_col() +
  labs(
    title = "Temps effectif par patient (trié) avec distinction Prio/Autres",
    x = "Patients",
    y = "Temps total dans le système (s)",
    fill = "Type de bureau"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())



```

**Analyse :**

Ce graphique nous permet de voir la dispersion des temps passés par les patients dans le système. On peut extrapoler une moyenne aux alentours de 350 secondes de temps passé par patient. On peut voir également que le temps total passé dans le système est un peu moins élevé pour les bureaux prioritaires car on a beaucoup moins de valeurs extrêmes comme le patient ayant passé plus de 1000s.

```{r answer 1.3.3}
ggplot(accueil, aes(x = type_bureau, y = W, fill = type_bureau)) +
  geom_boxplot() +
  labs(
    title = "Distribution des temps effectifs par type de bureau",
    x = "Type de bureau",
    y = "Temps total dans le système (s)"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

**Analyse :**

Ces deux boxplots permettent de voir que finalement les dispersions entre les deux services sont assez similaires mais que, ,comme dis précédemment le bureau prioritaire a moins de valeurs extrêmes. Donc en général un patient sera obligatoirement pris en charge rapidement dans le bureau prioritaire mais dans un accueil normal, le patient peut parfois attendre plus longtemps. Ceci reste cependant un cas à la marge.

```{r answer 1.3.4}
ggplot(L_tranches_bureau, aes(x = tranche, y = L, fill = type_bureau)) +
  geom_col(position = "dodge") +
  labs(
    title = "Nombre moyen de patients (L) par tranche et type de bureau",
    x = "Tranche horaire",
    y = "L (patients)",
    fill = "Type de bureau"
  ) +
  theme_minimal()
```

**Analyse :**

Ce graphique permet de mettre en évidence le nombre moyen de patient par tranche horaire et par bureau. On voit ainsi que le bureau prioritaire est toujours moins chargé et que les autres bureaux connaissent un pic important en début de journée.

```{r answer 1.3.5}
ggplot(W_tranches_bureau, aes(x = tranche, y = W_q / 60, fill = type_bureau)) +
  geom_col(position = "dodge") +
  labs(
    title = "Temps d'attente moyen (W_q) par tranche et type de bureau",
    x = "Tranche horaire",
    y = "Temps d'attente moyen (minutes)",
    fill = "Type de bureau"
  ) +
  theme_minimal()

```

**Analyse :**

Ce graphique permet de mettre en évidence le temps moyen d'attente à chaque bureau. On voit que pour la première tranche horaire un patient attend en moyenne 0.6 minutes dans un bureau de type Autres alors qu'il n'attend pas dans le bureau prioritaire.

```{r answer 1.3.6}
ggplot(lambda_tranches_bureau, aes(x = tranche, y = lambda, fill = type_bureau)) +
  geom_col(position = "dodge") +
  labs(
    title = "Taux d'arrivée moyen (λ) par tranche et type de bureau",
    x = "Tranche horaire",
    y = "Lambda (patients/h)",
    fill = "Type de bureau"
  ) +
  theme_minimal()

```

**Analyse :**

Ce graphique permet de visualiser le taux moyen d'arrivée de patient par heure. On voit que les bureaux prioritaires reçoivent bien moins de patients. On voit également de manière globale que sur tous les graphiques que la première période de la journée est toujours chargée et les délais de prise en charge sont plus longs pour les non prioritaires.

### Question 2) Modélisation du bureau d'accueil prioritaire (/5)

On commence à étudier le service du bureau d'accueil prioritaire comme un système à 1 serveur. N'oubliez pas de comparer à la réalité en tenant compte des approximations et hypothèses de modélisation implicites qui expliquerait des divergences.

2.1) Étudiez le modèle $M/M/1$ avec le taux de service $\mu_{Prio}$ et en regardant pour différent taux d'arrivée, en particulier $\lambda_{Prio},\lambda_{[8h;11h20],Prio}, \lambda_{[11h20;14h40],Prio}, \lambda_{[14h40;18h00,Prio]}$.

**Définition des paramètres M/M/1 :**

```{r answer 2.1.1}
library(dplyr)
library(ggplot2)

# Paramètres du bureau prioritaire
lambda_global <- sum(accueil$type_bureau == "Prio") / 10           
lambda_8h_11h20_Prio <- lambda_8h_11h20_Prio
lambda_11h20_14h40_Prio <- lambda_11h20_14h40_Prio
lambda_14h40_18h_Prio <- lambda_14h40_18h_Prio

mu_Prio <- 3600 / mean(accueil$S[accueil$type_bureau == "Prio"], na.rm = TRUE)  # patients/h

# Taux d'occupation
rho_global <- lambda_global / mu_Prio
rho_8h <- lambda_8h_11h20_Prio / mu_Prio
rho_11h <- lambda_11h20_14h40_Prio / mu_Prio
rho_14h <- lambda_14h40_18h_Prio / mu_Prio
```

Le taux de service μ du bureau prioritaire est estimé à partir du temps moyen de service observé dans les données. Les taux d’arrivée λ sont calculés pour différentes périodes de la journée afin de capturer la variabilité temporelle de la demande.

**Fonction M/M/1 et calcul des indicateurs :**

```{r answer 2.1.2}
library(knitr)
# Fonction M/M/1
calcul_MM1 <- function(lambda, mu, periode = "") {
  rho <- lambda / mu
  if (rho >= 1) {
    return(data.frame(
      Periode = periode, lambda=lambda, mu=mu, rho=rho,
      L_q = Inf, L = Inf, W_q_sec = Inf, W_sec = Inf, Stable="NON"
    ))
  }
  L_q <- rho^2 / (1 - rho)
  L <- rho / (1 - rho)
  W_q <- rho / (mu * (1 - rho)) * 3600  # secondes
  W <- 1 / (mu - lambda) * 3600        # secondes
  data.frame(
    Periode = periode, lambda=lambda, mu=mu, rho=round(rho, 4),
    L_q=round(L_q, 4), L=round(L, 4),
    W_q_sec=round(W_q,2), W_sec=round(W,2), Stable="OUI"
  )
}

# Calcul pour toutes les périodes
resultats_MM1 <- bind_rows(
  calcul_MM1(lambda_global, mu_Prio, "Global"),
  calcul_MM1(lambda_8h_11h20_Prio, mu_Prio, "[8h-11h20]"),
  calcul_MM1(lambda_11h20_14h40_Prio, mu_Prio, "[11h20-14h40]"),
  calcul_MM1(lambda_14h40_18h_Prio, mu_Prio, "[14h40-18h]")
)

print(kable(resultats_MM1, format = "simple"))


```

À partir des paramètres λ et μ, les indicateurs théoriques du modèle M/M/1 sont calculés pour chaque période. On vérifie en particulier la condition de stabilité du système (ρ \< 1) et on observe l’évolution des indicateurs de congestion lorsque le taux d’arrivée augmente.

**Probabilité d’état (P_n) en fonction de n et ρ :**

Pour un M/M/1, la probabilité d’avoir **n clients** dans le système :

Pn​=(1−ρ)ρ\^n

```{r answer 2.1.3}
library(ggplot2)
library(dplyr)

# Valeurs de rho à comparer
rho_values <- c(
  rho_global,
  lambda_8h_11h20_Prio / mu_Prio,
  lambda_11h20_14h40_Prio / mu_Prio,
  lambda_14h40_18h_Prio / mu_Prio
)

rho_labels <- c("Global", "[8h;11h20]", "[11h20;14h40]", "[14h40;18h00]")

# États n
n_max <- 10
n <- 0:n_max

# Construire la table des probabilités
prob_etat <- expand.grid(n = n, rho = rho_values) %>%
  mutate(
    P_n = (1 - rho) * rho^n,
    rho_factor = factor(rho, labels = rho_labels)
  )

# Graphique
ggplot(prob_etat, aes(x = n, y = P_n, fill = rho_factor)) +
  geom_col(position = "dodge") +
  labs(
    title = "Probabilité d'état stationnaire P(n) – Modèle M/M/1",
    subtitle = "Comparaison pour différents taux d'utilisation ρ",
    x = "Nombre de patients dans le système (n)",
    y = "Probabilité P(n)",
    fill = "Période (ρ)"
  ) +
  theme_minimal()

```

La probabilité d’état stationnaire P(n) permet d’analyser la distribution du nombre de patients présents dans le système. Lorsque le taux d’occupation ρ augmente, la probabilité d’observer des états avec un nombre élevé de patients devient plus importante, traduisant un risque accru de congestion.

**Graphique d’occupation moyenne (L et Lq)**

```{r answer 2.1.4}
# Graphique occupation
rho_seq <- seq(0.01, 0.95, by = 0.01)

df_theorie <- data.frame(
  rho = rho_seq,
  L = rho_seq / (1 - rho_seq),
  L_q = rho_seq^2 / (1 - rho_seq)
)

ggplot(df_theorie, aes(x = rho)) +
  geom_line(aes(y = L, color = "L"), linewidth = 1.2) +
  geom_line(aes(y = L_q, color = "L_q"), linewidth = 1.2) +
  scale_color_manual(values = c("L" = "blue", "L_q" = "green")) +
  labs(
    title = "Occupation moyenne théorique du système M/M/1",
    x = "Taux d'utilisation ρ",
    y = "Nombre moyen de patients",
    color = "Indicateur"
  ) +
  theme_minimal()


```

Ce graphique présente l’évolution théorique de l’occupation moyenne du système et de la file d’attente en fonction du taux d’utilisation ρ. On observe une croissance non linéaire, illustrant la forte sensibilité du système à une augmentation de la charge lorsque ρ se rapproche de 1.

**Comparaison théorie / empirique du temps d'attente :**

```{r answer 2.1.5}
# Exemple : données empiriques
donnees_empiriques <- data.frame(
  Periode=c("Global","[8h-11h20]","[11h20-14h40]","[14h40-18h]"),
  W_q_emp=c(1.3, 0, 0, 4.1),  # en secondes
  W_emp=c(398.57,449,345,358),
  L_q_emp=c(0.001,0,0,0.00205),
  L_emp=c(0.21,0.337,0.115,0.179)
)

library(tidyr)

df_Wq_plot <- comparaison %>%
  select(Periode, W_q_sec, W_q_empirique) %>%
  pivot_longer(cols = c(W_q_sec, W_q_empirique),
               names_to = "Source",
               values_to = "W_q")

ggplot(df_Wq_plot, aes(x = Periode, y = W_q, fill = Source)) +
  geom_col(position = "dodge") +
  labs(
    title = "Temps d'attente en file : Théorie M/M/1 vs Réalité",
    x = "Période",
    y = "Wq (secondes)",
    fill = ""
  ) +
  scale_fill_manual(
    values = c("W_q_sec" = "steelblue", "W_q_empirique" = "darkgreen"),
    labels = c("M/M/1", "Empirique")
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```

La comparaison entre les valeurs théoriques et empiriques montre que le modèle M/M/1 tend à surestimer le temps d’attente en file. Ceci s’explique notamment par la variabilité réelle des arrivées et par une organisation efficace du bureau prioritaire, conduisant à des files d’attente très faibles dans la pratique.

**Comparaison théorique / empirique de l'occupation moyenne :**

```{r answer 2.1.6}
df_L_plot <- comparaison %>%
  select(Periode, L, L_empirique, L_q, L_q_empirique) %>%
  pivot_longer(cols = -Periode)

ggplot(df_L_plot, aes(x = Periode, y = value, fill = name)) +
  geom_col(position = "dodge") +
  labs(
    title = "Occupation moyenne : Théorie vs Empirique",
    x = "Période",
    y = "Nombre moyen de patients"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

Les valeurs empiriques de l’occupation moyenne sont globalement inférieures aux valeurs théoriques prévues par le modèle M/M/1. Cela confirme que le bureau prioritaire fonctionne dans un régime peu congestionné, avec une capacité de service suffisante par rapport à la demande observée.

**Taux d'utilisation du bureau prioritaire :**

```{r answer 2.1.7}
ggplot(resultats_MM1, aes(x = Periode, y = rho)) +
  geom_col(fill = "coral") +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red") +
  labs(
    title = "Taux d'utilisation du bureau prioritaire",
    x = "Période",
    y = "ρ"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

Le taux d’utilisation du bureau prioritaire reste inférieur à 1 pour l’ensemble des périodes étudiées, garantissant la stabilité du système. Les variations de ρ selon les tranches horaires traduisent des différences de charge, sans toutefois atteindre un niveau critique de saturation.

2.2) Faites de même avec le modèle le modèle $M/G/1$ et grâce aux formules de Pollaczek-Khinchine (souvent abrégées formules P-K, voir Shortle et al. 2018 section 5).

**Fonction M/G/1 (formules de Pollaczek-Khinchine) :**

Pour un système M/G/1, les indicateurs de performance sont donnés par les formules de Pollaczek-Khinchine. En particulier, le nombre moyen de clients en file dépend non seulement du taux d’occupation ρ, mais aussi de la variabilité du service via le coefficient de variation.

```{r answer 2.2.1}

calcul_MG1 <- function(lambda, mu, cv, periode = "") {
  
  rho <- lambda / mu
  
  if (rho >= 1) {
    return(data.frame(
      Periode = periode,
      lambda = lambda,
      mu = mu,
      cv = cv,
      rho = rho,
      L_q = Inf,
      L = Inf,
      W_q_sec = Inf,
      W_sec = Inf,
      Stable = "NON"
    ))
  }
  
  # Formules de Pollaczek-Khinchine
  L_q <- (rho^2 * (1 + cv^2)) / (2 * (1 - rho))
  L <- rho + L_q
  
  # Loi de Little
  W_q_sec <- (L_q / lambda) * 3600
  W_sec <- (L / lambda) * 3600
  
  data.frame(
    Periode = periode,
    lambda = lambda,
    mu = mu,
    cv = cv,
    rho = round(rho, 4),
    L_q = round(L_q, 4),
    L = round(L, 4),
    W_q_sec = round(W_q_sec, 2),
    W_sec = round(W_sec, 2),
    Stable = "OUI"
  )
}
```

**Indicateurs théoriques M/G/1 par période :**

Les indicateurs M/G/1 sont calculés pour les mêmes périodes que dans l’étude M/M/1. Pour toutes les périodes, le taux d’occupation reste inférieur à 1, garantissant la stabilité du système.

```{r answer 2.2.2}
resultats_MG1 <- bind_rows(
  calcul_MG1(lambda_Prio,            mu_Prio, cv_S_Prio, "Global"),
  calcul_MG1(lambda_8h_11h20_Prio,   mu_Prio, cv_S_Prio, "[8h-11h20]"),
  calcul_MG1(lambda_11h20_14h40_Prio,mu_Prio, cv_S_Prio, "[11h20-14h40]"),
  calcul_MG1(lambda_14h40_18h_Prio,  mu_Prio, cv_S_Prio, "[14h40-18h]") 
)


kable(resultats_MG1, format = "simple")

```

**Comparaison M/M/1 vs M/G/1 vs empirique :**

```{r answer 2.2.3}
donnees_empiriques <- data.frame(
  Periode = c("Global", "[8h-11h20]", "[11h20-14h40]", "[14h40-18h]"),
  W_q_emp = c(1.30, 0, 0, 4.10),
  L_q_emp = c(0.001, 0, 0, 0.00205)
)

comparaison <- resultats_MM1 %>%
  select(Periode, W_q_MM1 = W_q_sec, L_q_MM1 = L_q) %>%
  left_join(
    resultats_MG1 %>% select(Periode, W_q_MG1 = W_q_sec, L_q_MG1 = L_q),
    by = "Periode"
  ) %>%
  left_join(donnees_empiriques, by = "Periode") %>%
  mutate(
    Gain_MG1 = W_q_MM1 - W_q_MG1,
    Gain_pct = round(100 * Gain_MG1 / W_q_MM1, 1)
  )

kable(comparaison, format = "simple")
```

Le modèle M/M/1 suppose implicitement un coefficient de variation égal à 1, correspondant à une loi exponentielle. Or, dans notre cas, le coefficient de variation observé est nettement inférieur, ce qui conduit le modèle M/M/1 à surestimer les temps d’attente et l’occupation moyenne.

**Graphique comparatif des temps d'attente en file :**

```{r answer 2.2.4}
library(tidyr)

df_plot <- comparaison %>%
  select(Periode, W_q_MM1, W_q_MG1, W_q_emp) %>%
  pivot_longer(cols = -Periode,
               names_to = "Modele",
               values_to = "W_q")

ggplot(df_plot, aes(x = Periode, y = W_q, fill = Modele)) +
  geom_col(position = "dodge") +
  labs(
    title = "Temps d'attente en file : comparaison des modèles",
    x = "Période",
    y = "Wq (secondes)"
  ) +
  scale_fill_manual(
    values = c("W_q_MM1" = "steelblue",
               "W_q_MG1" = "orange",
               "W_q_emp" = "darkgreen"),
    labels = c("M/M/1", "M/G/1", "Empirique")
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

**Analyse :**

Le graphique met en évidence que le modèle M/M/1 surestime systématiquement le temps d’attente en file par rapport au modèle M/G/1. Le modèle M/G/1 fournit des estimations plus proches des valeurs empiriques, notamment sur les périodes à faible charge. Cela confirme que la prise en compte de la variabilité réelle du service est essentielle pour une modélisation réaliste du système.

**Impact du coefficient de variation (P-K) :**

```{r answer 2.2.5}
cv_seq <- seq(0.1, 2, by = 0.05)
rho_test <- lambda_Prio / mu_Prio

df_cv <- data.frame(
  cv = cv_seq,
  L_q = (rho_test^2 * (1 + cv_seq^2)) / (2 * (1 - rho_test))
)

ggplot(df_cv, aes(x = cv, y = L_q)) +
  geom_line(color = "blue", linewidth = 1.2) +
  geom_vline(xintercept = cv_S_Prio, linetype = "dashed", color = "darkgreen") +
  geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
  labs(
    title = "Impact du coefficient de variation sur l'attente M/G/1",
    x = "Coefficient de variation (cv)",
    y = "Lq"
  ) +
  theme_minimal()

```

Lq**​ en fonction de ρ et du cv :**

```{r answer 2.2.6}
rho_seq <- seq(0.05, 0.95, by = 0.05)
cv_values <- c(0.3, 1, 1.5)

df_rho_cv <- expand.grid(rho = rho_seq, cv = cv_values) %>%
  mutate(
    L_q = (rho^2 * (1 + cv^2)) / (2 * (1 - rho)),
    cv = factor(cv)
  )

ggplot(df_rho_cv, aes(x = rho, y = L_q, color = cv)) +
  geom_line(linewidth = 1.2) +
  labs(
    title = "Influence conjointe de ρ et du coefficient de variation sur Lq (M/G/1)",
    x = "Taux d’occupation ρ",
    y = "Nombre moyen de clients en file Lq",
    color = "Coefficient de variation"
  ) +
  theme_minimal()

```

**Analyse :**

Ce graphique illustre le rôle central de la variabilité du service dans le modèle M/G/1. Pour un même taux d’occupation ρ, une augmentation du coefficient de variation entraîne une croissance rapide de la longueur moyenne de la file. Le cas cv=1 correspond au modèle M/M/1, tandis que notre situation réelle (cv≈0.3) conduit à une congestion beaucoup plus faible.

### Question 3) Modélisation des bureaux d'accueil non prioritaires (/5)

On continue avec les 3 autres bureaux.

3.1) Étudiez le modèle $M/M/3$ avec le taux de service $\mu_{Autres}$ et en regardant pour différent taux d'arrivée, en particulier $\lambda_{Autres},\lambda_{[8h;11h20],Autres}, \lambda_{[11h20;14h40],Autres}, \lambda_{[14h40;18h00,Autres]}$.

**Définition des paramètres :**

```{r answer 3.1.1}
# ==============================
# PARAMÈTRES M/M/3
# ==============================

# Nombre de serveurs
c <- 3

# Taux de service moyen (patients/heure)
mu_Autres <- 3600 / mean(accueil$S[accueil$type_bureau == "Autres"], na.rm = TRUE)

# Taux d'arrivée par période
lambda_global_Autres <- sum(accueil$type_bureau == "Autres") / 10
lambda_8h_11h20_Autres <- lambda_8h_11h20_Autres
lambda_11h20_14h40_Autres <- lambda_11h20_14h40_Autres
lambda_14h40_18h_Autres <- lambda_14h40_18h_Autres

# Taux d'utilisation
rho_global <- lambda_global_Autres / (c * mu_Autres)
rho_8h <- lambda_8h_11h20_Autres / (c * mu_Autres)
rho_11h <- lambda_11h20_14h40_Autres / (c * mu_Autres)
rho_14h <- lambda_14h40_18h_Autres / (c * mu_Autres)
```

On calcule :

ρ=λ/cμ

-   Condition de stabilité :

ρ\<1

Comme pour le bureau prioritaire, on observe un système stable pour toutes les périodes.

**Fonction M/M/3 et indicateurs :**

```{r answer 3.1.2.1}
calcul_MM3 <- function(lambda, mu, c, periode="") {
  
  a <- lambda / mu
  rho <- lambda / (c * mu)
  
  if (rho >= 1) {
    return(data.frame(
      Periode=periode, lambda=lambda, mu=mu, rho=rho,
      L_q=Inf, L=Inf, W_q_sec=Inf, W_sec=Inf,
      C_erlang=NA,
      Stable="NON"
    ))
  }
  
  # Calcul P0
  somme <- sum(sapply(0:(c-1), function(n) (a^n)/factorial(n)))
  terme_final <- (a^c/factorial(c)) * (c/(c-a))
  P0 <- 1/(somme + terme_final)
  
  # Erlang C
  C_erlang <- (a^c/factorial(c)) * P0 * (c/(c-a))
  
  L_q <- C_erlang * a/(c-a)
  L <- L_q + a
  
  W_q_sec <- (L_q/lambda)*3600
  W_sec <- (L/lambda)*3600
  
  data.frame(
    Periode=periode,
    rho=round(rho,4),
    C_erlang=round(C_erlang,4),
    L_q=round(L_q,4),
    L=round(L,4),
    W_q_sec=round(W_q_sec,2),
    W_sec=round(W_sec,2),
    Stable="OUI"
  )
}

resultats_MM3 <- bind_rows(
  calcul_MM3(lambda_global_Autres, mu_Autres, 3, "Global"),
  calcul_MM3(lambda_8h_11h20_Autres, mu_Autres, 3, "[8h-11h20]"),
  calcul_MM3(lambda_11h20_14h40_Autres, mu_Autres, 3, "[11h20-14h40]"),
  calcul_MM3(lambda_14h40_18h_Autres, mu_Autres, 3, "[14h40-18h]")
)

kable(resultats_MM3)
```

**Analyse**

Les résultats montrent que :

-   La longueur moyenne de file Lq​ est extrêmement faible (proche de 0).

-   Le temps d’attente Wq​ est inférieur à quelques secondes pour toutes les périodes.

-   Le nombre moyen de patients dans le système reste dominé par le service lui-même (et non par l’attente).

Ces résultats confirment que le système est très faiblement congestionné, même durant la tranche horaire la plus chargée.

**Taux d'utilisation :**

```{r answer 3.1.2.2}
ggplot(resultats_MM3, aes(x = Periode, y = rho * 100)) +
  geom_bar(stat = "identity", fill = "coral") +
  geom_hline(yintercept = 100, linetype = "dashed", color = "red", size = 1) +
  annotate("text", x = 1.5, y = 105, label = "Limite de stabilité (100%)", 
           color = "red") +
  labs(title = "Taux d'utilisation par serveur (ρ)",
       subtitle = "Bureaux d'Accueil Non Prioritaires",
       x = "Période",
       y = "ρ (%)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

**Analyse :**

Un ρ \< 25 % signifie que :

-    Chaque serveur est occupé en moyenne **moins d’un quart du temps**.

-   Les serveurs sont donc **largement sous-chargés**.

-    Le système fonctionne très loin de toute situation de saturation.

La limite théorique de stabilité (ρ = 1) correspond au cas où :

-    La capacité totale cμ est exactement égale au flux d’arrivée λ.

-   Le moindre aléa ferait exploser la file d’attente.

Ici, on est très loin de cette zone critique.

**Probabilité d’attente (Erlang C) :**

Equivalent du P(n) en M/M/1, mais ici on analyse :

P(Wq\>0)=C(c,a)

```{r answer 3.1.3}
ggplot(resultats_MM3, aes(x = Periode, y = C_erlang * 100)) +
  geom_bar(stat = "identity", fill = "purple") +
  labs(title = "Probabilité d'attendre (Erlang C)",
       subtitle = "Bureaux d'Accueil Non Prioritaires",
       x = "Période",
       y = "Probabilité (%)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

**Analyse**

La probabilité d’attente reste inférieure à 3 % sur l’ensemble des périodes.

Cela signifie qu’un patient a plus de 97 % de chances d’être pris en charge immédiatement à son arrivée.

Même en période haute ([8h;11h20]), le risque de trouver les trois serveurs simultanément occupés reste très limité.

**Comparaison théorie / empirique :**

```{r answer 3.1.4}
df_plot_wq <- comparaison_MM3 %>%
  select(Periode, W_q_sec, W_q_empirique) %>%
  tidyr::pivot_longer(cols = c(W_q_sec, W_q_empirique), 
                      names_to = "Type", 
                      values_to = "W_q")

ggplot(df_plot_wq, aes(x = Periode, y = W_q, fill = Type)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Comparaison W_q : M/M/3 vs Empirique",
       subtitle = "Bureaux d'Accueil Non Prioritaires (3 serveurs)",
       x = "Période",
       y = "Temps d'attente moyen en file (secondes)",
       fill = "Source") +
  scale_fill_manual(
    values = c("W_q_sec" = "steelblue", "W_q_empirique" = "darkgreen"),
    labels = c("W_q_sec" = "M/M/3 (théorique)", 
               "W_q_empirique" = "Empirique (réel)")
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

**Analyse**

Contrairement au bureau prioritaire étudié en question 2, le modèle M/M/3 tend ici à **sous-estimer** le temps d’attente réel.

Alors que le modèle prédit des attentes de l’ordre de quelques secondes, les données empiriques montrent :

-   environ 37 secondes sur la tranche [8h;11h20]

-   environ 19 secondes en moyenne globale

Cet écart peut s’expliquer par plusieurs facteurs :

-   des arrivées non parfaitement poissoniennes (arrivées groupées),

-   une non-stationnarité à l’intérieur des tranches horaires,

-   des contraintes organisationnelles non modélisées,

-   ou encore une variabilité du service différente de l’hypothèse exponentielle.

Le modèle reste néanmoins cohérent en ordre de grandeur et confirme l’absence de congestion structurelle.

**Effet du pooling (M/M/3 vs 3×M/M/1) :**

On compare :

-   une file unique avec 3 serveurs (M/M/3)

-   trois files séparées indépendantes (3 × M/M/1)

```{r answer 3.1.5}
ggplot(df_pooling, aes(x=Periode, y=W_q, fill=Architecture)) +
  geom_col(position="dodge") +
  labs(title="Effet du pooling",
       y="Wq (secondes)") +
  theme_minimal()
```

**Analyse :**

La mutualisation réduit significativement le temps d’attente moyen.

Avec trois files séparées, l’attente serait nettement plus élevée en raison d’un déséquilibre possible entre les files (certaines vides, d’autres saturées).

La file unique permet :

-   une meilleure utilisation des serveurs,

-   une réduction de la variance d’attente,

-   une amélioration globale de la performance.

Ce résultat confirme l’intérêt organisationnel du système mutualisé actuellement en place.

**Conclusion :**

Les bureaux d’accueil non prioritaires fonctionnent dans un régime très peu chargé, avec un taux d’utilisation inférieur à 25 % sur l’ensemble des périodes étudiées.

Le modèle M/M/3 montre :

-   une probabilité d’attente très faible,

-   une longueur moyenne de file quasi nulle,

-   un système largement stable.

Bien que le modèle sous-estime légèrement l’attente observée en pratique, il capture correctement la dynamique générale du système.

Enfin, l’analyse du pooling met en évidence l’intérêt majeur de la file unique mutualisée, qui réduit fortement les temps d’attente par rapport à une organisation en files séparées.

3.2) Étudiez le modèles comme un processus Markovien général avec un taux de service $mu_{Autres,i}$ qui dépend du niveau d'occupation et pour différent taux d'arrivée, en particulier $\lambda_{Autres},\lambda_{[8h;11h20],Autres}, \lambda_{[11h20;14h40],Autres}, \lambda_{[14h40;18h00,Autres]}$. **Attention** il vous faudra déterminer ces valeurs en analysant le taux de départ des 3 bureaux selon le niveau d'occupation.

**Reconstruction de la trajectoire du système :**

Nous nous concentrons uniquement sur les bureaux **« Autres »**, puis nous reconstruisons la chronologie complète des arrivées et des départs afin d’obtenir l’évolution du nombre de patients dans le système au cours du temps.

**Filtrage des données :**

```{r answer 3.2.1}
# ==============================
# 1. FILTRAGE DES BUREAUX "AUTRES"
# ==============================

accueil_autres <- accueil %>%
  filter(type_bureau == "Autres")

cat("Nombre de patients traités par les bureaux 'Autres':", 
    nrow(accueil_autres), "\n")
```

**Construction des événements ( arrivées + départs ) :**

```{r answer 3.2.2}
# ==============================
# 2. CONSTRUCTION DE LA CHRONOLOGIE (ARRIVÉES + DÉPARTS)
# ==============================

evenements <- bind_rows(
  accueil_autres %>% 
    transmute(time = ta, type = "arrivee", ID, CURRENT_LOCATION),
  accueil_autres %>% 
    transmute(time = td, type = "depart", ID, CURRENT_LOCATION)
) %>%
  arrange(time) %>%
  mutate(
    delta = ifelse(type == "arrivee", 1, -1),
    n_systeme = cumsum(delta)
  )
```

**Visulatisation de l'occupation :**

```{r answer 3.2.3}
# ==============================
# 3. VISUALISATION DE L’OCCUPATION
# ==============================

p_occupation <- ggplot(evenements, aes(x = time, y = n_systeme)) +
  geom_step(color = "blue", size = 0.8) +
  geom_hline(yintercept = c(1, 2, 3), 
             linetype = "dashed", color = "red", alpha = 0.5) +
  labs(title = "Occupation du système au cours du temps",
       subtitle = "Bureaux d'Accueil Non Prioritaires",
       x = "Heure",
       y = "Nombre de patients dans le système") +
  theme_minimal()

print(p_occupation)
```

**Analyse :**

Le graphique en escalier représente l’évolution du nombre de patients dans le système.

On observe :

-   des périodes où le système reste à 1 ou 2 patients,

-   des pics atteignant 3 patients (capacité maximale des serveurs),

-   des périodes de stabilisation lorsque les départs compensent les arrivées.

Ce graphique est fondamental car il permet ensuite d’estimer le **temps passé à chaque niveau d’occupation n**, nécessaire pour calculer μ(n).

**Estimation empirique des taux μ(n) :**

Nous calculons :

-   le temps total passé dans chaque état n,

-   le nombre de départs observés lorsque le système est à ce niveau,

-   puis :

μ(n)= nombre de départs à l’état n/temps total passé à l’état n​

```{r answer 3.2.4}
# ==============================
# 4. TEMPS PASSÉ PAR NIVEAU D’OCCUPATION
# ==============================

occupation_stats <- evenements %>%
  mutate(
    duree = lead(time) - time,
    duree_sec = as.numeric(duree, units = "secs")
  ) %>%
  filter(!is.na(duree_sec) & duree_sec > 0) %>%
  group_by(n_systeme) %>%
  summarise(
    temps_total_sec = sum(duree_sec),
    temps_total_heures = temps_total_sec / 3600,
    nb_departs = sum(lead(type) == "depart", na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    mu_n = nb_departs / temps_total_heures,
    mu_n = ifelse(is.finite(mu_n), mu_n, 0)
  )

kable(occupation_stats, format = "simple", digits = 3)
```

**Extraction des valeurs μ(n) :**

```{r answer 3.2.5}
# ==============================
# 5. EXTRACTION DES VALEURS μ(n)
# ==============================

mu_n_values <- occupation_stats %>%
  select(n_systeme, mu_n) %>%
  arrange(n_systeme)

mu_n_values
```

**Visualisation de μ(n):**

```{r answer 3.2.6}
# ==============================
# 6. GRAPHIQUE μ(n) EMPIRIQUE
# ==============================

p_mu_n <- ggplot(mu_n_values, aes(x = n_systeme, y = mu_n)) +
  geom_point(color = "darkred", size = 3) +
  geom_line(color = "darkred", linetype = "dashed") +
  geom_hline(yintercept = mu_Autres, 
             color = "blue", linetype = "dashed") +
  annotate("text",
           x = max(mu_n_values$n_systeme) * 0.8,
           y = mu_Autres + 1,
           label = paste0("μ théorique = ", round(mu_Autres, 2)),
           color = "blue") +
  labs(title = "Taux de service μ(n) selon le niveau d'occupation",
       subtitle = "Bureaux d'Accueil Non Prioritaires",
       x = "Nombre de patients dans le système (n)",
       y = "Taux de service μ(n) [patients/heure]") +
  theme_minimal()

print(p_mu_n)
```

**Analyse :**

Les résultats obtenus montrent que :

-   μ(0) = 0, ce qui est cohérent puisqu’aucun service ne peut avoir lieu en absence de patients.

-   μ(1) ≈ 9.05, ce qui correspond exactement au taux de service individuel estimé précédemment.

-   μ(2) ≈ 17, valeur proche de 2 × 9.05 = 18.1.

-   μ(3) ≈ 15, légèrement inférieur à 3 × 9.05 = 27.15

On observe donc que μ(n) augmente lorsque le nombre de patients augmente, ce qui est cohérent avec un système disposant de plusieurs serveurs travaillant en parallèle.

Cependant, pour n = 3, le taux observé est inférieur à la valeur théorique 3μ. Cela peut s’expliquer par :

-   un temps d’observation relativement faible dans cet état,

-   une variabilité statistique,

-   ou un léger ralentissement opérationnel lorsque le système est saturé.

Globalement, la structure empirique reste compatible avec un modèle à 3 serveurs

**Constructi**

**Construction du modèle Birth–Death général :**

**Construction du vecteur μ(n) :**

```{r answer 3.2.7}
# ==============================
# 7. CONSTRUCTION DU VECTEUR μ(n)
# ==============================

n_max <- max(mu_n_values$n_systeme, 20)

mu_n_vector <- sapply(0:n_max, function(n) {
  if (n == 0) return(0)
  if (n %in% mu_n_values$n_systeme) {
    return(mu_n_values$mu_n[mu_n_values$n_systeme == n])
  } else if (n <= 3) {
    return(min(n, 3) * mu_Autres)
  } else {
    return(3 * mu_Autres)
  }
})

df_mu_n <- data.frame(
  n = 0:min(10, n_max),
  mu_n = mu_n_vector[1:min(11, n_max + 1)]
)

kable(df_mu_n, format = "simple", digits = 3)
```

Ce vecteur :

-   reprend les valeurs empiriques lorsque disponibles,

-   prolonge la structure théorique au-delà des observations,

-   garantit la cohérence du processus Birth–Death.

**Fonction de calcul des probabilités stationnaires :**

```{r answer 3.2.8}
# ==============================
# 8. FONCTION PROCESSUS BIRTH-DEATH
# ==============================

calcul_birth_death <- function(lambda, mu_n_vec, n_max = 50) {

  pi <- numeric(n_max + 1)
  pi[1] <- 1

  for (n in 1:n_max) {
    if (mu_n_vec[n + 1] > 0) {
      pi[n + 1] <- pi[n] * lambda / mu_n_vec[n + 1]
    } else {
      pi[n + 1] <- Inf
      break
    }
  }

  if (any(is.infinite(pi))) return(NULL)

  pi <- pi / sum(pi)
  return(pi)
}
```

Cette fonction applique la formule récursive :

πn=πn−1\*λ/μ(n)​

puis normalise les probabilités.

**Calcul des indicateurs (L, Lq, W, Wq) :**

```{r answer 3.2.9}
# ==============================
# 9. CALCUL DES INDICATEURS MARKOV
# ==============================

calcul_indicateurs_markov <- function(lambda, mu_n_vec, nom_periode = "") {

  n_max <- length(mu_n_vec) - 1
  pi <- calcul_birth_death(lambda, mu_n_vec, n_max)

  if (is.null(pi)) {
    return(data.frame(
      Periode = nom_periode,
      L = Inf, L_q = Inf,
      W_sec = Inf, W_q_sec = Inf
    ))
  }

  c <- 3

  L <- sum((0:n_max) * pi)
  L_q <- sum(pmax(0, (0:n_max) - c) * pi)

  W_sec <- (L / lambda) * 3600
  W_q_sec <- (L_q / lambda) * 3600

  return(data.frame(
    Periode = nom_periode,
    L = round(L,4),
    L_q = round(L_q,4),
    W_sec = round(W_sec,2),
    W_q_sec = round(W_q_sec,2)
  ))
}
```

**Résultats par période :**

```{r answer 3.2.10}
# ==============================
# 10. RÉSULTATS MARKOV
# ==============================

resultats_markov <- bind_rows(
  calcul_indicateurs_markov(lambda_Autres, mu_n_vector, "Global (8h-18h)"),
  calcul_indicateurs_markov(lambda_8h_11h20_Autres, mu_n_vector, "[8h;11h20]"),
  calcul_indicateurs_markov(lambda_11h20_14h40_Autres, mu_n_vector, "[11h20;14h40]"),
  calcul_indicateurs_markov(lambda_14h40_18h_Autres, mu_n_vector, "[14h40;18h00]")  
)

kable(resultats_markov)
```

**Comparaison Markov vs M/M/3 vs Empirique :**

```{r answer 3.2.11}
# ==============================
# 11. TABLEAU DE COMPARAISON
# ==============================

comparaison_complete <- data.frame(
  Periode = resultats_markov$Periode,
  W_q_Markov = resultats_markov$W_q_sec,
  L_q_Markov = resultats_markov$L_q,
  W_q_MM3 = resultats_MM3$W_q_sec,
  L_q_MM3 = resultats_MM3$L_q,
  W_q_emp = donnees_empiriques_autres$W_q_empirique,
  L_q_emp = donnees_empiriques_autres$L_q_empirique
)

comparaison_complete
```

**Graphique comparatif des temps d’attente :**

```{r answer 3.2.12}
# ==============================
# 12. GRAPHIQUE COMPARAISON W_q
# ==============================

df_plot_comparison <- comparaison_complete %>%
  select(Periode, W_q_Markov, W_q_MM3, W_q_emp) %>%
  tidyr::pivot_longer(cols = c(W_q_Markov, W_q_MM3, W_q_emp), 
                      names_to = "Modele", 
                      values_to = "W_q")

p_comp <- ggplot(df_plot_comparison,
                 aes(x = Periode, y = W_q, fill = Modele)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Comparaison W_q : Markov général vs M/M/3 vs Empirique",
       subtitle = "Bureaux d'Accueil Non Prioritaires",
       x = "Période",
       y = "Temps d'attente moyen en file (secondes)",
       fill = "Modèle") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(p_comp)
```

**Analyse :**

Le graphique montre trois estimations :

-   modèle empirique (réalité observée),

-   modèle M/M/3 classique,

-   modèle Markovien général μ(n).

On constate généralement que :

-   le modèle M/M/3 tend à lisser les variations,

-   le modèle Markovien général se rapproche davantage des données empiriques,

-   les écarts sont plus marqués lors des périodes de forte affluence.

```{r answer 3.2.13}
# ==============================
# 13. GRAPHIQUE μ(n) EMPIRIQUE vs THÉORIQUE
# ==============================

df_mu_comparison <- data.frame(
  n = 0:10,
  mu_empirique = mu_n_vector[1:11],
  mu_theorique = sapply(0:10, function(n) min(n, 3) * mu_Autres)
)

df_mu_plot <- df_mu_comparison %>%
  tidyr::pivot_longer(cols = c(mu_empirique, mu_theorique), 
                      names_to = "Type", 
                      values_to = "mu")

p_mu_comp <- ggplot(df_mu_plot,
                    aes(x = n, y = mu, color = Type, group = Type)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  labs(title = "Comparaison μ(n) : Empirique vs Théorique M/M/3",
       x = "Nombre de clients dans le système (n)",
       y = "Taux de service μ(n)",
       color = "Source") +
  theme_minimal()

print(p_mu_comp)
```

**Analyse :**

Le graphique compare les taux de service empiriques et théoriques en fonction du nombre de patients dans le système. Pour n = 0, le taux est naturellement nul car il n’y a aucun patient. Pour n = 1 et n = 2, les valeurs empiriques sont proches de la théorie (μ(1) ≈ 9.05, μ(2) ≈ 17), ce qui indique que les serveurs commencent à travailler dès le premier patient. Pour n = 3, le taux empirique (15) est inférieur à la valeur théorique (≈27), ce qui suggère une légère saturation ou un temps très court passé à cet état. Dans l’ensemble, la tendance générale suit le comportement attendu d’un système M/M/3, mais les serveurs réels ne sont pas strictement parallèles et indépendants.

### Question 4) Modélisation alternative bureaux d'accueil comme d'un système à priorité (/5)

Supposons que le service d'accueil deviennent beaucoup plus performant et que les **temps de service moyens soient divisés par 4**. On se retrouve maintenant avec un système à 2 classes de priorité ($PC=2$) (cf Shortle et al. (2018), section 4.4, p172)

4.1) Etudiez le modèle $M/M/1/PC=2$ avec un taux d'arrivée $\lambda$ constant sur la journée et $\frac{\mu}{4} = \frac{1}{4\bar{S}}$

**Paramètres et stabilité du système :**

```{r answer 4.1.1}
# ========== DONNÉES DE BASE ========== 

# Taux d'arrivée globaux (de la question 1.2)
lambda_Prio <- 1.9          # patients/heure - Classe 1
lambda_Autres <- 4.9        # patients/heure - Classe 2
lambda_total <- lambda_Prio + lambda_Autres  # Total

# Temps de service moyens ACTUELS (secondes)
S_mean_Prio <- 3600 / mu_Prio      # De question 1.2
S_mean_Autres <- 3600 / mu_Autres  # De question 1.2

# Temps de service moyen pondéré actuel
S_mean_global <- (lambda_Prio * S_mean_Prio + lambda_Autres * S_mean_Autres) / lambda_total

# Taux de service moyen actuel
mu_actuel <- 3600 / S_mean_global

# NOUVEAU taux de service 
mu_nouveau <- mu_actuel * 4
```

On considère un système unifié à **1 serveur unique**, dont la performance est améliorée : les temps de service sont divisés par 4, donc le taux de service est multiplié par 4.

Le taux d’utilisation total est :

ρ=λ/μ

Avec les nouvelles performances, on obtient :

-    ρ ≈ 0,19 (soit 19 %)

La condition de stabilité ρ<1\rho < 1ρ\<1 est largement respectée.

Le système est donc **très peu chargé**, avec un serveur occupé moins de 20 % du temps.

**Calcul des indicateurs M/M/1/PC=2 :**

```{r answer 4.1.2}
calcul_MM1_PC2 <- function(lambda1, lambda2, mu, preemptive = FALSE) {
  # lambda1: taux arrivée classe haute priorité
  # lambda2: taux arrivée classe basse priorité
  # mu: taux de service
  # preemptive: TRUE si préemptif, FALSE si non-préemptif
  
  lambda_total <- lambda1 + lambda2
  rho1 <- lambda1 / mu
  rho2 <- lambda2 / mu
  rho <- rho1 + rho2
  
  # Vérifier stabilité
  if (rho >= 1) {
    return(list(
      stable = FALSE,
      rho = rho,
      rho1 = rho1,
      rho2 = rho2,
      W_q1 = Inf,
      W_q2 = Inf,
      W1 = Inf,
      W2 = Inf,
      L_q1 = Inf,
      L_q2 = Inf,
      L1 = Inf,
      L2 = Inf
    ))
  }
  
  # Temps de service moyen
  S_mean <- 1 / mu
  
  if (!preemptive) {
    # PRIORITÉ NON-PRÉEMPTIVE (Non-preemptive priority)
    
    # Temps d'attente moyen en file pour classe 1 (haute priorité)
    # W_q1 = ρ × S / (1 - ρ₁)
    W_q1_heures <- (rho * S_mean) / (1 - rho1)
    
    # Temps d'attente moyen en file pour classe 2 (basse priorité)
    # W_q2 = ρ × S / ((1 - ρ₁)(1 - ρ₁ - ρ₂))
    W_q2_heures <- (rho * S_mean) / ((1 - rho1) * (1 - rho))
    
  } else {
    # PRIORITÉ PRÉEMPTIVE (Preemptive resume priority)
    
    # Temps d'attente pour classe 1
    W_q1_heures <- rho1 * S_mean / (1 - rho1)
    
    # Temps d'attente pour classe 2
    W_q2_heures <- (rho * S_mean) / ((1 - rho1) * (1 - rho))
  }
  
  # Temps total dans le système
  W1_heures <- W_q1_heures + S_mean
  W2_heures <- W_q2_heures + S_mean
  
  # Nombre moyen via loi de Little
  L_q1 <- lambda1 * W_q1_heures
  L_q2 <- lambda2 * W_q2_heures
  L1 <- lambda1 * W1_heures
  L2 <- lambda2 * W2_heures
  
  # Conversion en secondes
  W_q1_sec <- W_q1_heures * 3600
  W_q2_sec <- W_q2_heures * 3600
  W1_sec <- W1_heures * 3600
  W2_sec <- W2_heures * 3600
  
  return(list(
    stable = TRUE,
    rho = rho,
    rho1 = rho1,
    rho2 = rho2,
    # Temps d'attente en file (secondes)
    W_q1_sec = W_q1_sec,
    W_q2_sec = W_q2_sec,
    # Temps total (secondes)
    W1_sec = W1_sec,
    W2_sec = W2_sec,
    # Nombre moyen
    L_q1 = L_q1,
    L_q2 = L_q2,
    L1 = L1,
    L2 = L2,
    L_q_total = L_q1 + L_q2,
    L_total = L1 + L2
  ))
}

# ========== CALCULS PRIORITÉ NON-PRÉEMPTIVE ========== 
cat("\n========== RÉSULTATS M/M/1/PC=2 (NON-PRÉEMPTIF) ==========\n\n")

resultats_PC2 <- calcul_MM1_PC2(lambda_Prio, lambda_Autres, mu_nouveau, preemptive = FALSE)

if (!resultats_PC2$stable) {
  cat("SYSTÈME INSTABLE ! ρ =", resultats_PC2$rho, "≥ 1\n")
} else {
  cat("TAUX D'UTILISATION:\n")
  cat(sprintf("  ρ₁ (Prioritaire) = %.4f\n", resultats_PC2$rho1))
  cat(sprintf("  ρ₂ (Non prioritaire) = %.4f\n", resultats_PC2$rho2))
  cat(sprintf("  ρ (Total) = %.4f\n\n", resultats_PC2$rho))
  
  cat("TEMPS D'ATTENTE EN FILE (W_q):\n")
  cat(sprintf("  Classe 1 (Prioritaire): %.2f secondes\n", resultats_PC2$W_q1_sec))
  cat(sprintf("  Classe 2 (Non prioritaire): %.2f secondes\n\n", resultats_PC2$W_q2_sec))
  
  cat("TEMPS TOTAL DANS LE SYSTÈME (W):\n")
  cat(sprintf("  Classe 1 (Prioritaire): %.2f secondes\n", resultats_PC2$W1_sec))
  cat(sprintf("  Classe 2 (Non prioritaire): %.2f secondes\n\n", resultats_PC2$W2_sec))
  
  cat("NOMBRE MOYEN EN FILE (L_q):\n")
  cat(sprintf("  Classe 1: %.4f patients\n", resultats_PC2$L_q1))
  cat(sprintf("  Classe 2: %.4f patients\n", resultats_PC2$L_q2))
  cat(sprintf("  Total: %.4f patients\n\n", resultats_PC2$L_q_total))
  
  cat("NOMBRE MOYEN DANS LE SYSTÈME (L):\n")
  cat(sprintf("  Classe 1: %.4f patients\n", resultats_PC2$L1))
  cat(sprintf("  Classe 2: %.4f patients\n", resultats_PC2$L2))
  cat(sprintf("  Total: %.4f patients\n\n", resultats_PC2$L_total))
}
```

**Analyse :**

Les résultats montrent que :

-    Le système reste stable (ρ \< 1).

-   Les patients prioritaires (classe 1) ont un temps d’attente plus faible que les non prioritaires.

-    La priorité redistribue l’attente : elle protège la classe 1 au détriment modéré de la classe 2.

Dans ce régime peu chargé (ρ ≈ 0,19), les temps d’attente restent globalement faibles pour les deux classes.

**Comparaison avec M/M/1 sans priorité (FIFO) :**

```{r answer 4.1.3}
# Calculer M/M/1 classique (sans priorité)
rho_sans_priorite <- lambda_total / mu_nouveau
L_q_sans_priorite <- rho_sans_priorite^2 / (1 - rho_sans_priorite)
L_sans_priorite <- rho_sans_priorite / (1 - rho_sans_priorite)
W_q_sans_priorite_sec <- (L_q_sans_priorite / lambda_total) * 3600
W_sans_priorite_sec <- (L_sans_priorite / lambda_total) * 3600

cat("M/M/1 SANS PRIORITÉ (FIFO):\n")
cat(sprintf("  W_q (tous patients) = %.2f secondes\n", W_q_sans_priorite_sec))
cat(sprintf("  W (tous patients) = %.2f secondes\n", W_sans_priorite_sec))
cat(sprintf("  L_q = %.4f patients\n", L_q_sans_priorite))
cat(sprintf("  L = %.4f patients\n\n", L_sans_priorite))

cat("M/M/1/PC=2 AVEC PRIORITÉ (NON-PRÉEMPTIF):\n")
cat(sprintf("  W_q Classe 1 = %.2f sec (%.1f%% du FIFO)\n", 
            resultats_PC2$W_q1_sec, 
            100 * resultats_PC2$W_q1_sec / W_q_sans_priorite_sec))
cat(sprintf("  W_q Classe 2 = %.2f sec (%.1f%% du FIFO)\n\n", 
            resultats_PC2$W_q2_sec,
            100 * resultats_PC2$W_q2_sec / W_q_sans_priorite_sec))

# Gains/pertes
gain_classe1 <- W_q_sans_priorite_sec - resultats_PC2$W_q1_sec
perte_classe2 <- resultats_PC2$W_q2_sec - W_q_sans_priorite_sec

cat("IMPACT DE LA PRIORITÉ:\n")
cat(sprintf("  Classe 1 (gain): -%.2f secondes (%.1f%% de réduction)\n", 
            gain_classe1,
            100 * gain_classe1 / W_q_sans_priorite_sec))
cat(sprintf("  Classe 2 (perte): +%.2f secondes (%.1f%% d'augmentation)\n\n", 
            perte_classe2,
            100 * perte_classe2 / W_q_sans_priorite_sec))
```

**Analyse :**

Le système FIFO (sans priorité) donne un temps d’attente identique pour tous les patients.

Avec priorité :

-    Les prioritaires gagnent environ 14 % de temps d’attente.

-    Les non prioritaires subissent une légère augmentation (\~5 %).

La priorité agit donc comme un **mécanisme de protection ciblée**, avec un coût modéré pour la classe 2.

**Comparaison avec le système actuel (4 serveurs) :**

```{r answer 4.1.4}
# Rappel des valeurs empiriques actuelles
W_q_actuel_Prio <- 1.30      # De question 1.2
W_q_actuel_Autres <- 18.53   # De question 1.2

cat("SYSTÈME ACTUEL (4 serveurs séparés):\n")
cat(sprintf("  W_q Prioritaire = %.2f secondes\n", W_q_actuel_Prio))
cat(sprintf("  W_q Non prioritaire = %.2f secondes\n\n", W_q_actuel_Autres))

cat("NOUVEAU SYSTÈME (1 serveur 4× plus rapide avec priorité):\n")
cat(sprintf("  W_q Classe 1 = %.2f secondes\n", resultats_PC2$W_q1_sec))
cat(sprintf("  W_q Classe 2 = %.2f secondes\n\n", resultats_PC2$W_q2_sec))

cat("ÉVOLUTION:\n")
cat(sprintf("  Classe 1: %.2f → %.2f secondes (×%.2f)\n", 
            W_q_actuel_Prio, resultats_PC2$W_q1_sec,
            resultats_PC2$W_q1_sec / W_q_actuel_Prio))
cat(sprintf("  Classe 2: %.2f → %.2f secondes (×%.2f)\n\n", 
            W_q_actuel_Autres, resultats_PC2$W_q2_sec,
            resultats_PC2$W_q2_sec / W_q_actuel_Autres))

```

Le système actuel à 4 serveurs reste plus performant pour les patients prioritaires, avec un temps d’attente quasi nul.

Le système unifié à priorité :

-    améliore la mutualisation,

-    mais ne dépasse pas la performance du système actuel.

On observe donc un compromis entre **mutualisation des ressources** et **performance absolue.**

**Comparaison des temps d'attente :**

```{r answer 4.1.5}
df_comparison_wq <- data.frame(
  Systeme = rep(c("Actuel (4 serveurs)", "FIFO (1 serveur ×4)", "Priorité (1 serveur ×4)"), each = 2),
  Classe = rep(c("Prioritaire", "Non prioritaire"), 3),
  W_q = c(
    W_q_actuel_Prio, W_q_actuel_Autres,
    W_q_sans_priorite_sec, W_q_sans_priorite_sec,
    resultats_PC2$W_q1_sec, resultats_PC2$W_q2_sec
  )
)

p1 <- ggplot(df_comparison_wq, aes(x = Systeme, y = W_q, fill = Classe)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Comparaison des temps d'attente W_q",
       subtitle = "Système actuel vs Nouveau système (service ×4)",
       x = "Configuration du système",
       y = "Temps d'attente moyen en file (secondes)",
       fill = "Type de patient") +
  scale_fill_manual(values = c("Prioritaire" = "darkgreen", "Non prioritaire" = "orange")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(p1)
```

La comparaison montre que :

-    Le système actuel reste optimal pour les prioritaires.

-   Le FIFO dégrade la performance surtout pour les prioritaires.

-    Le système à priorité permet de récupérer une partie de la performance perdue pour les prioritaires.

La priorité constitue potentiellement une solution intermédiaire.

**Impact de la priorité :**

```{r answer 4.1.6}
df_impact <- data.frame(
  Classe = c("Prioritaire", "Non prioritaire"),
  Delta_W_q = c(-gain_classe1, perte_classe2),
  Pct = c(-100 * gain_classe1 / W_q_sans_priorite_sec,
          100 * perte_classe2 / W_q_sans_priorite_sec)
)

p2 <- ggplot(df_impact, aes(x = Classe, y = Delta_W_q, fill = Classe)) +
  geom_bar(stat = "identity") +
  geom_hline(yintercept = 0, linetype = "solid", color = "black") +
  geom_text(aes(label = sprintf("%.1f%%", Pct)), vjust = -0.5, size = 5) +
  labs(title = "Impact de la priorité sur les temps d'attente",
       subtitle = "Variation par rapport à FIFO",
       x = "Classe de patient",
       y = "Δ W_q (secondes)") +
  scale_fill_manual(values = c("Prioritaire" = "darkgreen", "Non prioritaire" = "orange")) +
  theme_minimal() +
  guides(fill = "none")

print(p2)
```

**Analyse :**

Le graphique met en évidence :

-    un gain clair pour les prioritaires,

-   une perte modérée pour les non prioritaires.

La priorité introduit une redistribution contrôlée du temps d’attente.

**Sensibilité au taux d'utilisation p :**

```{r answer 4.1.7}
rho_values <- seq(0.1, 0.95, by = 0.05)
lambda_test <- rho_values * mu_nouveau
prop_prio <- lambda_Prio / lambda_total  # Proportion de patients prioritaires

df_rho_analysis <- do.call(rbind, lapply(lambda_test, function(lambda) {
  lambda1 <- lambda * prop_prio
  lambda2 <- lambda * (1 - prop_prio)
  res <- calcul_MM1_PC2(lambda1, lambda2, mu_nouveau, FALSE)
  
  data.frame(
    rho = lambda / mu_nouveau,
    W_q_classe1 = res$W_q1_sec,
    W_q_classe2 = res$W_q2_sec,
    W_q_fifo = (res$rho^2 / (1 - res$rho)) / lambda * 3600
  )
}))

df_rho_plot <- df_rho_analysis %>%
  tidyr::pivot_longer(cols = c(W_q_classe1, W_q_classe2, W_q_fifo),
                      names_to = "Type",
                      values_to = "W_q")

p3 <- ggplot(df_rho_plot, aes(x = rho, y = W_q, color = Type, linetype = Type)) +
  geom_line(size = 1.2) +
  geom_vline(xintercept = resultats_PC2$rho, linetype = "dashed", color = "red") +
  annotate("text", x = resultats_PC2$rho, y = max(df_rho_plot$W_q) * 0.9,
           label = sprintf("ρ actuel = %.3f", resultats_PC2$rho), 
           hjust = -0.1, color = "red") +
  labs(title = "Sensibilité de W_q au taux d'utilisation ρ",
       subtitle = "Système M/M/1/PC=2 vs M/M/1",
       x = "Taux d'utilisation ρ = λ/μ",
       y = "Temps d'attente moyen W_q (secondes)",
       color = "Type",
       linetype = "Type") +
  scale_color_manual(
    values = c("W_q_classe1" = "darkgreen", "W_q_classe2" = "orange", "W_q_fifo" = "blue"),
    labels = c("W_q_classe1" = "Prioritaire", "W_q_classe2" = "Non prioritaire", "W_q_fifo" = "FIFO")
  ) +
  scale_linetype_manual(
    values = c("W_q_classe1" = "solid", "W_q_classe2" = "solid", "W_q_fifo" = "dashed"),
    labels = c("W_q_classe1" = "Prioritaire", "W_q_classe2" = "Non prioritaire", "W_q_fifo" = "FIFO")
  ) +
  theme_minimal()

print(p3)
```

**Analyse :**

L’analyse de sensibilité montre que :

-    Pour des valeurs faibles de ρ (comme ici, 0,188), les trois systèmes sont proches.

-   Lorsque ρ augmente (\> 0,75), l’attente des non prioritaires et du FIFO explose.

-   En revanche, l’attente des prioritaires reste bien maîtrisée.

Cela montre que la priorité devient **stratégiquement très intéressante lorsque la charge augmente**.

**Distribution du nombre de patients :**

```{r answer 4.1.8}
n_max <- 20
pi <- numeric(n_max + 1)
pi[1] <- 1 - resultats_PC2$rho  # π(0)

for (n in 1:n_max) {
  pi[n + 1] <- pi[1] * resultats_PC2$rho^n
}

df_distribution <- data.frame(
  n = 0:n_max,
  probabilite = pi
)

p4 <- ggplot(df_distribution, aes(x = n, y = probabilite)) +
  geom_bar(stat = "identity", fill = "steelblue", alpha = 0.7) +
  labs(title = "Distribution du nombre de patients dans le système",
       subtitle = sprintf("M/M/1/PC=2 avec ρ = %.3f", resultats_PC2$rho),
       x = "Nombre de patients (n)",
       y = "Probabilité π(n)") +
  theme_minimal()

print(p4)
```

**Analyse :**

Avec ρ ≈ 0,188 :

-   Le système est vide dans plus de 80 % des cas.

-    La probabilité d’avoir 2 patients ou plus devient rapidement négligeable.

Le système est donc très peu congestionné dans les conditions actuelles.

**Conclusion :**

Le modèle M/M/1/PC=2 avec un taux d'arrivée $\lambda$ constant sur la journée et $\frac{\mu}{4} = \frac{1}{4\bar{S}}$ montre que :

-   Le système reste très stable (ρ ≈ 19 %).

-   La priorité protège efficacement les patients urgents.

-    Le coût pour les non prioritaires reste modéré.

-    L’intérêt du système prioritaire devient majeur lorsque la charge augmente.

Dans la configuration actuelle (faible ρ), les différences restent limitées, mais l’analyse de sensibilité montre que la priorité constitue une stratégie robuste en cas de hausse future de la demande.

4.2) Etudiez le modèle $M/M/1/PC=2$ avec un taux d'arrivée $\lambda$ constant sur la journée et un taux de service selon le type de patient $\frac{\mu_{1}}{4} = \frac{\mu_{Prio}}{4} = \frac{1}{4\bar{S}_{Prio}}$, $\frac{\mu_{2}}{4} = \frac{\mu_{Autres}}{4} = \frac{1}{4\bar{S}_{Autres}}$

**Paramètres et stabilité :**

```{r answer 4.2.1}
library(dplyr)
library(ggplot2)

# Taux d'arrivée
lambda_Prio <- 1.9
lambda_Autres <- 4.9
lambda_total <- lambda_Prio + lambda_Autres

# Taux de service actuels
mu_Prio_actuel <- 9.062
mu_Autres_actuel <- 9.055

# Nouveaux taux (service 4x plus rapide)
mu1_nouveau <- mu_Prio_actuel * 4
mu2_nouveau <- mu_Autres_actuel * 4

# Temps de service
S1 <- 1 / mu1_nouveau
S2 <- 1 / mu2_nouveau

# Proportions
p1 <- lambda_Prio / lambda_total
p2 <- lambda_Autres / lambda_total

# Temps de service moyen
S_mean <- p1*S1 + p2*S2

# Taux d'utilisation
rho <- lambda_total * S_mean

cat("rho =", rho, "\n")
```

**Analyse :**

Le taux d’utilisation global vaut **ρ = 0,188** environ.\
Comme **ρ \< 1**, le système est stable.

Le serveur est occupé environ **19 % du temps**, ce qui indique un système faiblement chargé.

La différenciation des taux de service n’affecte pas la stabilité, mais modifie le temps de service moyen E[S], ce qui influencera les temps d’attente.

**Temps d’attente en file (formule M/G/1 avec priorité) :**

```{r answer 4.2.2}
# Second moment du service
E_S2 <- p1*(2/mu1_nouveau^2) + p2*(2/mu2_nouveau^2)

# Temps d'attente moyen M/G/1
W_q_MG1 <- (lambda_total * E_S2) / (2*(1-rho))

# Utilisation par classe
rho1 <- lambda_Prio * S1
rho2 <- lambda_Autres * S2

# Priorité non préemptive
W_q1 <- W_q_MG1 / (1 - rho1)
W_q2 <- W_q_MG1 / ((1 - rho1)*(1 - rho))

# Conversion en secondes
W_q1_sec <- W_q1 * 3600
W_q2_sec <- W_q2 * 3600

cat("W_q1 =", W_q1_sec, "sec\n")
cat("W_q2 =", W_q2_sec, "sec\n")
```

**Analyse :**

Les temps d’attente moyens en file sont :

-   Classe prioritaire : **≈ 25 secondes**

-    Classe non prioritaire : **≈ 30 secondes**

La priorité continue donc de protéger la classe 1.\
Cependant, la différenciation des taux de service modifie légèrement les valeurs par rapport à la question 4.1.

L’impact reste limité car **μ₁ ≈ μ₂** (quasi identiques).

**Temps total dans le système :**

```{r answer 4.2.3}
# Temps total
W1 <- W_q1 + S1
W2 <- W_q2 + S2

W1_sec <- W1 * 3600
W2_sec <- W2 * 3600

cat("W1 =", W1_sec, "sec\n")
cat("W2 =", W2_sec, "sec\n")
```

**Analyse :**

Les temps totaux dans le système sont d’environ :

-    Classe 1 : **125–130 secondes**

-    Classe 2 : **130 secondes**

Contrairement au temps d’attente seul, le temps total est fortement influencé par le temps de service.\
Comme les temps de service ont été divisés par 4, le temps total reste **très inférieur au système initial** (\~400 secondes).

**Comparaison avec Q4.1 :**

```{r answer 4.2.3}
diff_W_q1 <- W_q1_sec - resultats_PC2$W_q1_sec
diff_W_q2 <- W_q2_sec - resultats_PC2$W_q2_sec

cat("Delta W_q1 =", diff_W_q1, "\n")
cat("Delta W_q2 =", diff_W_q2, "\n")
```

La différenciation des taux entraîne :

-   +5 secondes environ pour la classe 1

-   +5 secondes environ pour la classe 2

Les différences sont faibles car le ratio :

μ1/μ2≈1,001

Autrement dit, les deux classes ont pratiquement le même temps de service.

**Comparaison des temps d'attente Wq :**

```{r answer 4.2.4}
df_comp_wq <- data.frame(
  Configuration = rep(c("Actuel (4 serveurs)", "Q4.1 (μ identique)", "Q4.2 (μ différenciés)"), each = 2),
  Classe = rep(c("Prioritaire", "Non prioritaire"), 3),
  W_q = c(
    W_q_actuel_Prio, W_q_actuel_Autres,
    resultats_PC2$W_q1_sec, resultats_PC2$W_q2_sec,
    resultats_PC2_diff$W_q1_sec, resultats_PC2_diff$W_q2_sec
  )
)

p1 <- ggplot(df_comp_wq, aes(x = Configuration, y = W_q, fill = Classe)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Comparaison des temps d'attente W_q",
       subtitle = "Système actuel vs Q4.1 vs Q4.2",
       x = "Configuration",
       y = "Temps d'attente moyen en file (secondes)",
       fill = "Classe") +
  scale_fill_manual(values = c("Prioritaire" = "darkgreen", "Non prioritaire" = "orange")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(p1)
```

**Analyse :**

Ce graphique compare les temps d’attente moyens en file pour les trois configurations :

-    Système actuel (4 serveurs),

-    Q4.1 : M/M/1/PC=2 avec μ identique,

-    Q4.2 : M/M/1/PC=2 avec μ différenciés.

On observe que :

-   Le passage à un serveur unique (Q4.1 et Q4.2) modifie la structure d’attente

-    La classe prioritaire conserve un avantage clair dans toutes les configurations.

-    La différence entre Q4.1 et Q4.2 est très faible.

Cela s’explique par le fait que :

μ1/μ2≈1

Les taux de service étant presque identiques, la différenciation a un impact très limité sur les temps d’attente.

**Comparaison des temps totaux W :**

```{r answer 4.2.5}
df_comp_w <- data.frame(
  Configuration = rep(c("Actuel (4 serveurs)", "Q4.1 (μ identique)", "Q4.2 (μ différenciés)"), each = 2),
  Classe = rep(c("Prioritaire", "Non prioritaire"), 3),
  W = c(
    W_actuel_Prio, W_actuel_Autres,
    resultats_PC2$W1_sec, resultats_PC2$W2_sec,
    resultats_PC2_diff$W1_sec, resultats_PC2_diff$W2_sec
  )
)

p2 <- ggplot(df_comp_w, aes(x = Configuration, y = W, fill = Classe)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Comparaison des temps totaux W",
       subtitle = "Système actuel vs Q4.1 vs Q4.2",
       x = "Configuration",
       y = "Temps total dans le système (secondes)",
       fill = "Classe") +
  scale_fill_manual(values = c("Prioritaire" = "darkgreen", "Non prioritaire" = "orange")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(p2)
```

**Analyse :**

Ce graphique compare le temps total passé dans le système (attente + service).

On remarque que :

-    Le temps total diminue fortement par rapport au système initial.

-    Cette amélioration provient principalement de la division par 4 des temps de service.

-   La différence entre Q4.1 et Q4.2 reste marginale.

Cela montre que, dans un système faiblement chargé (ρ ≈ 0,19), le temps de service domine largement le temps total.

**Impact de la différenciation :**

```{r answer 4.2.6}
df_impact_diff <- data.frame(
  Classe = c("Prioritaire", "Non prioritaire"),
  Delta_W_q = c(diff_W_q1, diff_W_q2),
  Delta_W = c(diff_W1, diff_W2)
) %>%
  tidyr::pivot_longer(cols = c(Delta_W_q, Delta_W), 
                      names_to = "Indicateur",
                      values_to = "Delta")

p3 <- ggplot(df_impact_diff, aes(x = Classe, y = Delta, fill = Indicateur)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_hline(yintercept = 0, linetype = "solid", color = "black") +
  labs(title = "Impact de la différenciation des taux de service",
       subtitle = "Différence Q4.2 - Q4.1",
       x = "Classe de patient",
       y = "Δ temps (secondes)",
       fill = "Indicateur") +
  scale_fill_manual(
    values = c("Delta_W_q" = "steelblue", "Delta_W" = "coral"),
    labels = c("Delta_W_q" = "ΔW_q (file)", "Delta_W" = "ΔW (total)")
  ) +
  theme_minimal()

print(p3)
```

**Analyse :**

Ce graphique représente :

-    ΔW_q = différence d’attente

-    ΔW = différence de temps total

On observe que :

-    Les variations sont faibles.

-    Il n’y a pas de modification structurelle du système.

La différenciation des taux de service n’a qu’un effet marginal dans notre cas, car μ₁ et μ₂ sont quasi identiques.

**Décomposition** W=Wq+S :

```{r answer 4.2.7}
df_decomposition <- data.frame(
  Scenario = rep(c("Q4.1 Classe 1", "Q4.1 Classe 2", "Q4.2 Classe 1", "Q4.2 Classe 2"), each = 2),
  Composante = rep(c("Attente (W_q)", "Service (S)"), 4),
  Temps = c(
    resultats_PC2$W_q1_sec, 3600/mu_nouveau,
    resultats_PC2$W_q2_sec, 3600/mu_nouveau,
    resultats_PC2_diff$W_q1_sec, resultats_PC2_diff$S1 * 3600,
    resultats_PC2_diff$W_q2_sec, resultats_PC2_diff$S2 * 3600
  )
)

p4 <- ggplot(df_decomposition, aes(x = Scenario, y = Temps, fill = Composante)) +
  geom_bar(stat = "identity") +
  labs(title = "Décomposition du temps total (W = W_q + S)",
       subtitle = "Comparaison Q4.1 vs Q4.2",
       x = "Scénario",
       y = "Temps (secondes)",
       fill = "Composante") +
  scale_fill_manual(values = c("Attente (W_q)" = "orange", "Service (S)" = "steelblue")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(p4)

```

**Analyse :**

Ce graphique décompose le temps total en :

-    Attente (W_q)

-   Service (S)

On constate que :

-   La composante service représente la majorité du temps total.

-    L’attente reste faible grâce au faible taux d’utilisation.

-   La structure est quasiment identique entre Q4.1 et Q4.2.

Cela confirme que le système fonctionne en régime peu congestionné.

**Sensibilité au ratio μ₁/μ₂ :**

```{r answer 4.2.8}
mu_ratios <- seq(0.5, 2, by = 0.1)
df_sensitivity <- do.call(rbind, lapply(mu_ratios, function(ratio) {
  mu1_test <- mu_moyen * ratio
  mu2_test <- mu_moyen / ratio
  
  res <- calcul_MM1_PC2_diff(lambda_Prio, lambda_Autres, mu1_test, mu2_test, FALSE)
  
  data.frame(
    ratio = ratio,
    W_q1 = res$W_q1_sec,
    W_q2 = res$W_q2_sec,
    W1 = res$W1_sec,
    W2 = res$W2_sec
  )
}))

df_sens_plot <- df_sensitivity %>%
  tidyr::pivot_longer(cols = c(W_q1, W_q2), 
                      names_to = "Classe",
                      values_to = "W_q")

p5 <- ggplot(df_sens_plot, aes(x = ratio, y = W_q, color = Classe, linetype = Classe)) +
  geom_line(size = 1.2) +
  geom_vline(xintercept = mu1_nouveau / mu2_nouveau, linetype = "dashed", color = "red") +
  annotate("text", x = mu1_nouveau / mu2_nouveau, y = max(df_sens_plot$W_q) * 0.9,
           label = sprintf("Ratio actuel = %.3f", mu1_nouveau / mu2_nouveau),
           hjust = -0.1, color = "red") +
  labs(title = "Sensibilité de W_q au ratio μ₁/μ₂",
       subtitle = "Impact de la différenciation des taux de service",
       x = "Ratio μ₁/μ₂",
       y = "Temps d'attente W_q (secondes)",
       color = "Classe",
       linetype = "Classe") +
  scale_color_manual(
    values = c("W_q1" = "darkgreen", "W_q2" = "orange"),
    labels = c("W_q1" = "Prioritaire", "W_q2" = "Non prioritaire")
  ) +
  scale_linetype_manual(
    values = c("W_q1" = "solid", "W_q2" = "solid"),
    labels = c("W_q1" = "Prioritaire", "W_q2" = "Non prioritaire")
  ) +
  theme_minimal()

print(p5)

```

**Analyse :**

Ce graphique montre l’évolution de Wq​ en fonction du ratio μ₁/μ₂.

On observe que :

-    Lorsque le ratio est proche de 1, les deux classes ont des performances similaires.

-    Si μ₁ augmente fortement, l’attente des prioritaires diminue.

-    En contrepartie, l’attente des non prioritaires augmente.

La ligne verticale rouge indique le ratio actuel, qui est très proche de 1.

**Conclusion :**

Dans notre configuration réelle, la différenciation des taux de service n’apporte pas de gain significatif.

**Analyse détaillée :**

```{r answer 4.2.9}
cat("1. IMPACT DE LA DIFFÉRENCIATION DES TAUX:\n")
cat(sprintf("   - μ₁/μ₂ = %.3f (ratio des taux de service)\n", mu1_nouveau / mu2_nouveau))
cat(sprintf("   - S₁/S₂ = %.3f (ratio inverse des temps)\n", S1_nouveau / S2_nouveau))
cat("\n   Observations:\n")
if (abs(mu1_nouveau - mu2_nouveau) < 0.1) {
  cat("   - Les taux sont QUASI IDENTIQUES\n")
  cat("   - Impact MINIMAL de la différenciation\n")
} else if (mu1_nouveau > mu2_nouveau) {
  cat("   - μ₁ > μ₂ : Les patients prioritaires sont servis PLUS VITE\n")
  cat("   - Cela RENFORCE l'avantage de la priorité\n")
} else {
  cat("   - μ₁ < μ₂ : Les patients prioritaires sont servis MOINS VITE\n")
  cat("   - Cela COMPENSE partiellement l'avantage de la priorité\n")
}
cat("\n")

cat("2. COMPARAISON Q4.1 vs Q4.2:\n")
cat("   Question 4.1 (μ identique):\n")
cat("   - Hypothèse simplificatrice : tous les patients prennent le même temps\n")
cat("   - Seule la PRIORITÉ différencie les classes\n")
cat("\n   Question 4.2 (μ différenciés):\n")
cat("   - Plus RÉALISTE : chaque classe a son propre temps de service\n")
cat("   - DEUX facteurs jouent :\n")
cat("     (a) La priorité d'accès au serveur\n")
cat("     (b) Le temps de service lui-même\n\n")

cat("3. EFFET SUR LES INDICATEURS:\n")
cat(sprintf("   Classe 1 (Prioritaire):\n"))
cat(sprintf("   - W_q passe de %.2f à %.2f sec (%+.1f%%)\n",
            resultats_PC2$W_q1_sec, resultats_PC2_diff$W_q1_sec,
            100 * diff_W_q1 / resultats_PC2$W_q1_sec))
cat(sprintf("   - W passe de %.2f à %.2f sec (%+.1f%%)\n",
            resultats_PC2$W1_sec, resultats_PC2_diff$W1_sec,
            100 * diff_W1 / resultats_PC2$W1_sec))
cat("\n")
cat(sprintf("   Classe 2 (Non prioritaire):\n"))
cat(sprintf("   - W_q passe de %.2f à %.2f sec (%+.1f%%)\n",
            resultats_PC2$W_q2_sec, resultats_PC2_diff$W_q2_sec,
            100 * diff_W_q2 / resultats_PC2$W_q2_sec))
cat(sprintf("   - W passe de %.2f à %.2f sec (%+.1f%%)\n\n",
            resultats_PC2$W2_sec, resultats_PC2_diff$W2_sec,
            100 * diff_W2 / resultats_PC2$W2_sec))

cat("4. INTERPRÉTATION DU RATIO μ₁/μ₂:\n")
ratio_mu <- mu1_nouveau / mu2_nouveau
if (abs(ratio_mu - 1) < 0.01) {
  cat("   - Ratio ≈ 1 : pas de différence de service\n")
  cat("   - Q4.1 et Q4.2 donnent des résultats IDENTIQUES\n")
} else if (ratio_mu > 1) {
  cat("   - Ratio > 1 : classe 1 servie plus rapidement\n")
  cat(sprintf("   - Avantage supplémentaire de %.1f%% pour la classe 1\n", 
              100 * (ratio_mu - 1)))
} else {
  cat("   - Ratio < 1 : classe 1 servie plus lentement\n")
  cat(sprintf("   - Pénalité de %.1f%% pour la classe 1\n", 
              100 * (1 - ratio_mu)))
}
cat("\n")

cat("5. VALIDITÉ DU MODÈLE:\n")
cat("   Le modèle M/M/1/PC=2 avec μ différenciés est plus réaliste car:\n")
cat("   - Les types de patients ont effectivement des besoins différents\n")
cat("   - Les temps de service observés diffèrent légèrement\n")
cat(sprintf("   - μ_Prio = %.3f vs μ_Autres = %.3f (écart de %.1f%%)\n",
            mu_Prio_actuel, mu_Autres_actuel, 
            100 * abs(mu_Prio_actuel - mu_Autres_actuel) / mu_Autres_actuel))
cat("\n")
```

**Synthèse :**

```{r answer 4.2.10}
cat("\n========== SYNTHÈSE Q4.2 ==========\n\n")

cat("RÉSULTATS PRINCIPAUX:\n\n")

cat("1. SYSTÈME STABLE:\n")
cat(sprintf("   - ρ = %.4f < 1 ✓\n", resultats_PC2_diff$rho))
cat(sprintf("   - Occupation: %.1f%%\n\n", resultats_PC2_diff$rho * 100))

cat("2. TAUX DE SERVICE DIFFÉRENCIÉS:\n")
cat(sprintf("   - μ₁ = %.3f patients/h (S₁ = %.2f sec)\n", mu1_nouveau, S1_nouveau))
cat(sprintf("   - μ₂ = %.3f patients/h (S₂ = %.2f sec)\n", mu2_nouveau, S2_nouveau))
cat(sprintf("   - Ratio μ₁/μ₂ = %.3f (quasi identique)\n\n", ratio_mu))

cat("3. COMPARAISON Q4.1 vs Q4.2:\n")
if (abs(diff_W_q1) < 1 && abs(diff_W_q2) < 1) {
  cat("   - Différences NÉGLIGEABLES entre les deux modèles\n")
  cat("   - Justifié par μ₁ ≈ μ₂\n")
} else {
  cat("   - Différences SIGNIFICATIVES entre les deux modèles\n")
  cat("   - Impact de la différenciation visible\n")
}
cat("\n")

cat("4. PERTINENCE PRATIQUE:\n")
cat("   - Le modèle avec μ différenciés est plus RÉALISTE\n")
cat("   - Mais si μ₁ ≈ μ₂, le modèle simplifié (Q4.1) suffit\n")
cat("   - Dans notre cas: différence <1%, Q4.1 acceptable\n\n")

cat("5. COMPARAISON AVEC SYSTÈME ACTUEL:\n")
if (resultats_PC2_diff$W_q1_sec < W_q_actuel_Prio && 
    resultats_PC2_diff$W_q2_sec < W_q_actuel_Autres) {
  cat("   - ✓ Amélioration pour TOUTES les classes\n")
} else if (resultats_PC2_diff$W_q1_sec > W_q_actuel_Prio && 
           resultats_PC2_diff$W_q2_sec > W_q_actuel_Autres) {
  cat("   - ✗ Dégradation pour TOUTES les classes\n")
} else {
  cat("   - ± Compromis : amélioration d'une classe, dégradation de l'autre\n")
}
cat("\n")

cat("RECOMMANDATIONS:\n")
cat("- Utiliser le modèle avec μ différenciés pour plus de précision\n")
cat("- Mesurer empiriquement μ₁ et μ₂ pour chaque classe\n")
cat("- Si μ₁ ≈ μ₂, le modèle simplifié (Q4.1) est suffisant\n")
cat("- Attention à l'impact sur les temps de service totaux (W)\n")
```

Le modèle M/M/1/PC=2 avec μ différenciés est plus réaliste d’un point de vue théorique.\

Toutefois, comme l’écart entre μ₁ et μ₂ est inférieur à 1%, les résultats sont quasiment identiques au modèle simplifié de la question 4.1.\

Dans ce contexte, le modèle simplifié peut être considéré comme suffisant.

### Discussion supplémentaire (points complémentaires sur chaque question)

Pour tout point à approfondir sur la discussion globale des modèles et de leur comparaison qui n'aurait pas pu être fait avant ....

**Réponse :**

Le modèle M/M/3 pour les bureaux non-prioritaires donne des prédictions beaucoup \> plus cohérentes avec la réalité que M/M/1 pour le bureau prioritaire.

**Taux d'utilisation** : ρ = 18% signifie que chaque serveur est occupé seulement \> 18% du temps.Le système est **largement sur-dimensionné**, ce qui explique les \> temps d'attente très faibles.

**Probabilité d'attendre (Erlang C)** : Selon le modèle, seulement 2-5% des \> patients doivent attendre en moyenne. Cela correspond bien aux observations \> empiriques où W_q médian est probablement proche de 0.

**Avantage du pooling** : La mutualisation (1 file commune pour 3 serveurs) réduit \> les temps d'attente de 30-40% par rapport à 3 files séparées. C'est un **choix \> organisationnel optimal**.

**Limites** : Comme pour M/M/1, les hypothèses d'arrivées Poissoniennes et de \> stationnarité ne sont pas vérifiées. Cependant, le modèle M/M/3 reste une \> **approximation raisonnable** pour ce système peu chargé."

### Question bonus (+1)

En utilisant la théorie des files d'attentes et *l'Effective Process Time* pour les temps de service, on a simplifié grandement le comportement du système. Proposez des points précis pour obtenir une modélisation plus complète des services, en particulier pour un modèle de simulation détaillé, et en quoi cela améliorait le modèle tout en considérant les risques de modélisation que cela engendrerait.

```{r answer bonus}

cat("\n" %>% strrep(80), "\n")
cat("========== QUESTION BONUS : VERS UNE MODÉLISATION PLUS COMPLÈTE ==========\n")
cat(strrep("=", 80), "\n\n")

cat("INTRODUCTION:\n")
cat("Les modèles analytiques de files d'attente (M/M/c, M/G/c, M/M/1/PC=2) reposent\n")
cat("sur des hypothèses simplificatrices qui peuvent s'éloigner de la réalité.\n")
cat("Nous proposons des améliorations pour une modélisation plus fidèle, tout en\n")
cat("évaluant les bénéfices et risques associés.\n\n")

# ========== PARTIE 1 : LIMITATIONS ACTUELLES ==========
cat(strrep("-", 80), "\n")
cat("PARTIE 1 : LIMITATIONS DU MODÈLE ACTUEL\n")
cat(strrep("-", 80), "\n\n")

limitations <- data.frame(
  Aspect = c(
    "Temps de service",
    "Arrivées",
    "Stationnarité",
    "Indépendance",
    "Effective Process Time",
    "Priorité",
    "Ressources",
    "Comportement patients"
  ),
  Hypothese_actuelle = c(
    "Distribution exponentielle (M/M) ou générale (M/G)",
    "Processus de Poisson homogène",
    "Paramètres constants sur toute la journée",
    "Événements indépendants",
    "Ignore les temps d'attente internes au service",
    "Modèle simple (préemptif/non-préemptif)",
    "Serveurs identiques et indépendants",
    "Patients passifs, pas d'abandon"
  ),
  Realite_observee = c(
    "Mélange de distributions, variabilité complexe",
    "RDV programmés + arrivées spontanées",
    "Variations horaires fortes (8h≠12h≠16h)",
    "Corrélations temporelles, groupes",
    "Temps administratifs, déplacements, attentes cachées",
    "Multiples critères, règles complexes",
    "Compétences variables, fatigue, pauses",
    "Abandons, impatience, no-shows"
  ),
  Impact = c(
    "Sous/sur-estimation de W_q",
    "Prédictions erronées aux heures de pointe",
    "Modèle global peu précis",
    "Sous-estimation de la variance",
    "Biais dans les temps de service",
    "Modèle trop simpliste",
    "Capacité réelle mal estimée",
    "L_q et W_q surestimés"
  )
)

cat("Tableau récapitulatif des limitations:\n\n")
print(kable(limitations, format = "simple"))

# ========== PARTIE 2 : PROPOSITIONS D'AMÉLIORATION ==========
cat("\n\n")
cat(strrep("-", 80), "\n")
cat("PARTIE 2 : PROPOSITIONS D'AMÉLIORATION DÉTAILLÉES\n")
cat(strrep("-", 80), "\n\n")

# --- AMÉLIORATION 1 : DÉCOMPOSITION DÉTAILLÉE DU TEMPS DE SERVICE ---
cat( strrep("=", 80), "\n")
cat("AMÉLIORATION 1 : DÉCOMPOSITION DÉTAILLÉE DU TEMPS DE SERVICE\n")
cat( strrep("=", 80), "\n\n")

cat("PROBLÈME ACTUEL:\n")
cat("- L'Effective Process Time agrège tous les sous-processus en un temps unique\n")
cat("- Masque la complexité interne de chaque activité\n")
cat("- Empêche l'identification de goulots d'étranglement spécifiques\n\n")

cat("PROPOSITION:\n")
cat("Décomposer chaque activité en micro-étapes avec leurs distributions propres:\n\n")

cat("Exemple pour le bureau d'ACCUEIL:\n")
cat("  1. Vérification identité       : Lognormale(μ=15s, σ=8s)\n")
cat("  2. Recherche dossier           : Gamma(α=2, β=10s)\n")
cat("  3. Vérification RDV            : Lognormale(μ=20s, σ=12s)\n")
cat("  4. Mise à jour administrative  : Normale(μ=30s, σ=15s)\n")
cat("  5. Remise documents            : Constante(10s)\n")
cat("  6. Indication direction        : Normale(μ=15s, σ=5s)\n")
cat("  ---------------------------------------------------\n")
cat("  Temps total S = S1 + S2 + S3 + S4 + S5 + S6\n\n")

cat("IMPLÉMENTATION EN SIMULATION:\n")
cat("```r\n")
cat("service_accueil <- function() {\n")
cat("  t_verif_id <- rlnorm(1, meanlog=log(15), sdlog=log(1.5))\n")
cat("  t_recherche <- rgamma(1, shape=2, scale=10)\n")
cat("  t_verif_rdv <- rlnorm(1, meanlog=log(20), sdlog=log(1.6))\n")
cat("  t_admin <- rnorm(1, mean=30, sd=15)\n")
cat("  t_docs <- 10\n")
cat("  t_direction <- rnorm(1, mean=15, sd=5)\n")
cat("  \n")
cat("  return(t_verif_id + t_recherche + t_verif_rdv + \n")
cat("         t_admin + t_docs + t_direction)\n")
cat("}\n")
cat("```\n\n")

cat("BÉNÉFICES:\n")
cat("  ✓ Identification précise des goulots (ex: 'recherche dossier' trop long)\n")
cat("  ✓ Possibilité d'interventions ciblées (ex: améliorer le système informatique)\n")
cat("  ✓ Distribution totale plus réaliste (convolution de lois)\n")
cat("  ✓ Permet de modéliser des dépendances (ex: si dossier manquant → +délai)\n")
cat("  ✓ cv_S calculé naturellement à partir des composantes\n\n")

cat("RISQUES:\n")
cat("  ✗ Complexité accrue : N activités × M sous-étapes = beaucoup de paramètres\n")
cat("  ✗ Collecte de données difficile : chronométrage fin requis\n")
cat("  ✗ Risque de sur-paramétrisation : overfitting sur un jour spécifique\n")
cat("  ✗ Validation difficile : comment vérifier chaque micro-étape ?\n")
cat("  ✗ Temps de calcul : simulation plus lente\n\n")

cat("DONNÉES NÉCESSAIRES:\n")
cat("  - Chronométrage détaillé de chaque sous-étape (n ≥ 30 observations)\n")
cat("  - Vidéos ou observation directe pour validation\n")
cat("  - Identification des cas particuliers (dossier manquant, nouveau patient, etc.)\n\n")

# --- AMÉLIORATION 2 : PROCESSUS D'ARRIVÉE NON-POISSONNIEN ---
cat("\n")
cat( strrep("=", 80), "\n")
cat("AMÉLIORATION 2 : PROCESSUS D'ARRIVÉE RÉALISTE (NON-POISSONNIEN)\n")
cat( strrep("=", 80), "\n\n")

cat("PROBLÈME ACTUEL:\n")
cat("- Hypothèse d'arrivées Poissoniennes (exponentielles, indépendantes)\n")
cat("- Ne capture pas les RDV programmés\n")
cat("- Ignore les arrivées groupées (famille, transport commun)\n")
cat("- Taux constant par tranche horaire\n\n")

cat("PROPOSITION:\n")
cat("Modèle hybride combinant plusieurs types d'arrivées:\n\n")

cat("A) ARRIVÉES PROGRAMMÉES (Rendez-vous):\n")
cat("   - Planning déterministe: RDV à 8h15, 8h30, 8h45, ...\n")
cat("   - Variabilité d'arrivée: Normale(heure_RDV, σ=5min)\n")
cat("   - Probabilité de no-show: p_noshow = 0.05 (5%)\n")
cat("   - Exemple: RDV 9h00 → arrivée réelle ~ N(9h00, 5min)\n\n")

cat("B) ARRIVÉES SPONTANÉES (Sans RDV):\n")
cat("   - Processus de Poisson non-homogène: λ(t)\n")
cat("   - Taux variable dans le temps:\n")
cat("     λ(t) = λ_base × f(t)\n")
cat("     où f(t) = facteur multiplicatif horaire\n")
cat("   - Exemple: f(8h-9h)=1.5, f(12h-13h)=0.3, f(16h-17h)=1.2\n\n")

cat("C) ARRIVÉES GROUPÉES:\n")
cat("   - Groupes (famille): Poisson composé\n")
cat("   - Nombre par groupe: Géométrique(p=0.7) + 1\n")
cat("   - 70% individuels, 20% binômes, 7% trios, 3% groupes ≥4\n\n")

cat("IMPLÉMENTATION:\n")
cat("```r\n")
cat("# Fonction de taux d'arrivée variable\n")
cat("lambda_t <- function(heure) {\n")
cat("  base <- 5  # patients/heure en moyenne\n")
cat("  facteur <- case_when(\n")
cat("    heure >= 8 & heure < 9 → 1.8,    # Pic matinal\n")
cat("    heure >= 9 & heure < 11 → 1.3,\n")
cat("    heure >= 11 & heure < 13 → 0.4,  # Creux midi\n")
cat("    heure >= 13 & heure < 15 → 1.0,\n")
cat("    heure >= 15 & heure < 17 → 1.2,\n")
cat("    TRUE → 0.8\n")
cat("  )\n")
cat("  return(base * facteur)\n")
cat("}\n\n")
cat("# Simulation d'arrivées\n")
cat("generer_arrivees <- function(t_debut, t_fin) {\n")
cat("  arrivees <- c()\n")
cat("  \n")
cat("  # 1) RDV programmés\n")
cat("  rdv_planifies <- seq(t_debut, t_fin, by=15*60)  # Tous les 15 min\n")
cat("  rdv_reels <- rdv_planifies + rnorm(length(rdv_planifies), 0, 5*60)\n")
cat("  rdv_reels <- rdv_reels[runif(length(rdv_reels)) > 0.05]  # 5% no-show\n")
cat("  \n")
cat("  # 2) Arrivées spontanées (Poisson non-homogène)\n")
cat("  t <- t_debut\n")
cat("  while(t < t_fin) {\n")
cat("    heure <- hour(t) + minute(t)/60\n")
cat("    lambda_actuel <- lambda_t(heure)\n")
cat("    delta_t <- rexp(1, lambda_actuel/3600)\n")
cat("    t <- t + delta_t\n")
cat("    if(t < t_fin) arrivees <- c(arrivees, t)\n")
cat("  }\n")
cat("  \n")
cat("  # 3) Combiner et trier\n")
cat("  all_arrivees <- sort(c(rdv_reels, arrivees))\n")
cat("  return(all_arrivees)\n")
cat("}\n")
cat("```\n\n")

cat("BÉNÉFICES:\n")
cat("  ✓ Capture la RÉALITÉ des consultations hospitalières\n")
cat("  ✓ Prédictions plus précises aux heures de pointe\n")
cat("  ✓ Permet d'évaluer impact de la gestion de RDV\n")
cat("  ✓ Modélise les no-shows (impact important)\n")
cat("  ✓ Gère la non-stationnarité naturellement\n\n")

cat("RISQUES:\n")
cat("  ✗ Nécessite des DONNÉES de planning (non disponibles dans le log RFID)\n")
cat("  ✗ Estimation de λ(t) difficile si données limitées\n")
cat("  ✗ Hypothèses sur taux de no-show et arrivées groupées à valider\n")
cat("  ✗ Plus de paramètres à calibrer: risque d'incohérence\n\n")

cat("DONNÉES NÉCESSAIRES:\n")
cat("  - Planning des RDV sur plusieurs semaines\n")
cat("  - Horodatage réel d'arrivée vs heure RDV programmée\n")
cat("  - Taux de no-show par type de consultation\n")
cat("  - Composition des groupes arrivant ensemble\n\n")

# --- AMÉLIORATION 3 : MODÈLE NON-STATIONNAIRE ---
cat("\n")
cat( strrep("=", 80), "\n")
cat("AMÉLIORATION 3 : MODÈLE NON-STATIONNAIRE PAR TRANCHES FINES\n")
cat( strrep("=", 80), "\n\n")

cat("PROBLÈME ACTUEL:\n")
cat("- 3 tranches de 3h20 (~200 min) : granularité grossière\n")
cat("- Variations intra-tranche ignorées\n")
cat("- Hypothèse de stationnarité locale discutable\n\n")

cat("PROPOSITION:\n")
cat("Découpage en tranches de 30 minutes avec modèle dynamique:\n\n")

cat("APPROCHE 1 : Modèle M(t)/M(t)/c(t) (Time-varying parameters)\n")
cat("  - λ(t), μ(t), c(t) changent toutes les 30 minutes\n")
cat("  - 20 tranches de 30 min entre 8h et 18h\n")
cat("  - Exemple:\n")
cat("    [8h00-8h30]: λ=8.5, μ=9.1, c=3\n")
cat("    [8h30-9h00]: λ=9.2, μ=9.0, c=3\n")
cat("    [9h00-9h30]: λ=7.8, μ=9.2, c=3\n")
cat("    ...\n\n")

cat("APPROCHE 2 : Modèle avec transitions fluides\n")
cat("  - Interpolation cubique entre points de contrôle\n")
cat("  - λ(t) = fonction spline sur les données empiriques\n")
cat("  - Évite les discontinuités artificielles\n\n")

cat("IMPLÉMENTATION (Approche 1):\n")
cat("```r\n")
cat("# Paramètres par tranche de 30 min\n")
cat("tranches_30min <- data.frame(\n")
cat("  debut = seq(8*60, 17.5*60, by=30),  # minutes depuis 00h00\n")
cat("  lambda = c(8.5, 9.2, 7.8, 6.5, 5.2, 4.0, 3.5, 3.8,\n")
cat("             4.5, 5.2, 6.0, 6.8, 7.2, 7.0, 6.5, 6.2,\n")
cat("             5.8, 5.5, 5.0, 4.5),\n")
cat("  mu = rep(9.0, 20),  # Peut varier aussi (fatigue, etc.)\n")
cat("  c_actifs = c(3, 3, 3, 3, 3, 2, 2, 2,  # Nombre de serveurs actifs\n")
cat("               2, 3, 3, 3, 3, 3, 3, 3,\n")
cat("               3, 3, 2, 2)\n")
cat(")\n\n")
cat("# Simulation avec changement de paramètres\n")
cat("simuler_journee <- function() {\n")
cat("  for(i in 1:nrow(tranches_30min)) {\n")
cat("    t_debut <- tranches_30min$debut[i]\n")
cat("    t_fin <- t_debut + 30\n")
cat("    lambda_i <- tranches_30min$lambda[i]\n")
cat("    mu_i <- tranches_30min$mu[i]\n")
cat("    c_i <- tranches_30min$c_actifs[i]\n")
cat("    \n")
cat("    # Simuler cette tranche avec paramètres fixes\n")
cat("    simmer() %>%\n")
cat("      add_resource('serveurs', capacity=c_i) %>%\n")
cat("      add_generator('patients', trajectoire_patient, \n")
cat("                    function() rexp(1, lambda_i/60)) %>%\n")
cat("      run(until=30)\n")
cat("  }\n")
cat("}\n")
cat("```\n\n")

cat("BÉNÉFICES:\n")
cat("  ✓ Capture les variations FINES de charge\n")
cat("  ✓ Détecte les pics transitoires (ex: 8h45-9h15)\n")
cat("  ✓ Permet d'optimiser les horaires de pause du personnel\n")
cat("  ✓ Modélise la montée en charge progressive (8h = système vide)\n")
cat("  ✓ Plus proche de la réalité empirique\n\n")

cat("RISQUES:\n")
cat("  ✗ Multiplication des paramètres: 20 tranches × 3 param = 60 valeurs\n")
cat("  ✗ Données insuffisantes par tranche (1 seul jour = ~2-3 patients/tranche)\n")
cat("  ✗ Risque d'overfitting: modèle qui colle trop au 12/11/2015\n")
cat("  ✗ Instabilité numérique aux transitions\n")
cat("  ✗ Difficile d'obtenir indicateurs analytiques (besoin simulation)\n\n")

cat("DONNÉES NÉCESSAIRES:\n")
cat("  - Au moins 20-30 jours de données similaires\n")
cat("  - Test de stationnarité statistique par tranche\n")
cat("  - Validation croisée sur jours non utilisés pour calibration\n\n")

# --- AMÉLIORATION 4 : COMPORTEMENT PATIENT AVANCÉ ---
cat("\n")
cat( strrep("=", 80), "\n")
cat("AMÉLIORATION 4 : COMPORTEMENT PATIENT RÉALISTE (IMPATIENCE, ABANDON)\n")
cat( strrep("=", 80), "\n\n")

cat("PROBLÈME ACTUEL:\n")
cat("- Patients modélisés comme passifs et patients\n")
cat("- Restent indéfiniment en file même si attente longue\n")
cat("- Pas de modélisation de l'insatisfaction\n\n")

cat("PROPOSITION:\n")
cat("Modèle M/M/c + Impatience + Reneging:\n\n")

cat("A) IMPATIENCE (Reneging = abandon après arrivée):\n")
cat("   - Chaque patient a une 'patience maximale' aléatoire\n")
cat("   - Si W_q > Patience → abandon sans service\n")
cat("   - Distribution: Exponentielle(θ) ou Lognormale\n")
cat("   - Exemple: Patience ~ Exp(θ=10min)\n")
cat("     → 50% abandonnent après >10 min d'attente\n\n")

cat("B) BALKING (Refus d'entrer dans le système):\n")
cat("   - Si file trop longue à l'arrivée → ne se met pas en file\n")
cat("   - Probabilité de balking: P(balk|L_q=n) = 1/(1+exp(a-b×n))\n")
cat("   - Exemple: P(balk|L_q=0)=5%, P(balk|L_q=10)=50%\n\n")

cat("C) JOCKEYING (Changement de file):\n")
cat("   - Si plusieurs files: patient change vers file plus courte\n")
cat("   - Règle: si |L_q,other - L_q,current| > 2 → switch\n\n")

cat("IMPLÉMENTATION:\n")
cat("```r\n")
cat("# Modèle avec impatience\n")
cat("trajectoire_avec_impatience <- trajectory() %>%\n")
cat("  # Générer patience du patient\n")
cat("  set_attribute('patience', function() rexp(1, 1/600)) %>%  # 10 min moy\n")
cat("  \n")
cat("  # Renounce si on sait qu'on va abandonner\n")
cat("  renege_in(\n")
cat("    function() get_attribute(env, 'patience'),\n")
cat("    out = trajectory() %>%\n")
cat("      log_('Patient abandonne par impatience') %>%\n")
cat("      set_attribute('abandon', 1)\n")
cat("  ) %>%\n")
cat("  \n")
cat("  # Service normal\n")
cat("  seize('serveur') %>%\n")
cat("  renege_abort() %>%  # Patient pris en charge, ne renonce plus\n")
cat("  timeout(function() rexp(1, mu/3600)) %>%\n")
cat("  release('serveur')\n\n")
cat("# Modèle avec balking\n")
cat("p_balk <- function() {\n")
cat("  L_q <- get_queue_count(env, 'serveur')\n")
cat("  p <- 1 / (1 + exp(2 - 0.3*L_q))  # Fonction logistique\n")
cat("  return(runif(1) < p)\n")
cat("}\n\n")
cat("trajectoire_avec_balking <- trajectory() %>%\n")
cat("  branch(\n")
cat("    function() p_balk(),\n")
cat("    continue = FALSE,\n")
cat("    trajectory() %>% log_('Patient refuse d\\'entrer (balking)')\n")
cat("  ) %>%\n")
cat("  seize('serveur') %>%\n")
cat("  # ... suite normale\n")
cat("```\n\n")

cat("BÉNÉFICES:\n")
cat("  ✓ RÉALISME accru: capture comportement humain réel\n")
cat("  ✓ Prédictions plus précises de L_q (files plus courtes en réalité)\n")
cat("  ✓ Permet d'évaluer impact de l'insatisfaction\n")
cat("  ✓ Utile pour dimensionnement: éviter seuils d'abandon\n")
cat("  ✓ KPI additionnels: taux d'abandon, temps avant abandon\n\n")

cat("RISQUES:\n")
cat("  ✗ TRÈS difficile à calibrer: comment mesurer la 'patience' ?\n")
cat("  ✗ Nécessite données d'abandon (non présentes dans log RFID actuel)\n")
cat("  ✗ Hypothèse de distribution de patience non vérifiable\n")
cat("  ✗ Interaction complexe avec autres paramètres\n")
cat("  ✗ Risque de sur-modélisation si taux d'abandon faible (<5%)\n\n")

cat("DONNÉES NÉCESSAIRES:\n")
cat("  - Observation directe: patients qui partent sans être servis\n")
cat("  - Questionnaires: 'combien de temps étiez-vous prêt à attendre ?'\n")
cat("  - Analyse des tags RFID: patients qui quittent sans passer au bureau\n")
cat("  - Comparaison planning vs réel: RDV non honorés ≠ no-shows\n\n")

# --- AMÉLIORATION 5 : RESSOURCES HUMAINES RÉALISTES ---
cat("\n")
cat(strrep("=", 80), "\n")
cat("AMÉLIORATION 5 : MODÉLISATION DÉTAILLÉE DES RESSOURCES HUMAINES\n")
cat( strrep("=", 80), "\n\n")

cat("PROBLÈME ACTUEL:\n")
cat("- Serveurs identiques et toujours disponibles\n")
cat("- Pas de pauses, fatigue, variations de performance\n")
cat("- Pas de multi-compétences ou spécialisations\n\n")

cat("PROPOSITION:\n")
cat("Modèle multi-agents avec ressources hétérogènes:\n\n")

cat("A) SERVEURS HÉTÉROGÈNES:\n")
cat("   - Compétences différentes par agent:\n")
cat("     * Agent A: Expert → μ_A = 12 patients/h\n")
cat("     * Agent B: Moyen → μ_B = 9 patients/h\n")
cat("     * Agent C: Junior → μ_C = 6 patients/h\n")
cat("   - Affectation: Priorité aux experts si disponibles\n\n")

cat("B) FATIGUE ET APPRENTISSAGE:\n")
cat("   - Taux de service variable dans le temps:\n")
cat("     μ(t) = μ_base × (1 - α×fatigue(t) + β×apprentissage(t))\n")
cat("   - Fatigue: croît linéairement, reset après pause\n")
cat("     fatigue(t) = min(0.3, 0.02 × heures_travaillees)\n")
cat("   - Apprentissage: amélioration sur la journée\n")
cat("     apprentissage(t) = 0.1 × log(1 + nb_patients_traites/10)\n\n")

cat("C) PAUSES ET DISPONIBILITÉ:\n")
cat("   - Planning de pauses:\n")
cat("     * Agent 1: pause 10h30-10h45, 15h00-15h15\n")
cat("     * Agent 2: pause 11h00-11h15, 15h30-15h45\n")
cat("     * Agent 3: pause 11h30-11h45, 16h00-16h15\n")
cat("   - Réduction temporaire de capacité: c(t) variable\n")
cat("   - Absences imprévues: probabilité p=0.05/jour\n\n")

cat("D) MULTI-COMPÉTENCES:\n")
cat("   - Certains agents peuvent servir plusieurs files:\n")
cat("     * Infirmier IDE peut faire: prélèvements OU examens\n")
cat("     * Réaffectation dynamique selon charge\n\n")

cat("IMPLÉMENTATION:\n")
cat("```r\n")
cat("# Définir les agents avec propriétés\n")
cat("agents <- data.frame(\n")
cat("  id = c('A', 'B', 'C'),\n")
cat("  competence = c('expert', 'moyen', 'junior'),\n")
cat("  mu_base = c(12, 9, 6),\n")
cat("  pause_1 = c('10:30', '11:00', '11:30'),\n")
cat("  pause_2 = c('15:00', '15:30', '16:00')\n")
cat(")\n\n")
cat("# Fonction de taux de service dynamique\n")
cat("mu_dynamique <- function(agent_id, t, nb_traites) {\n")
cat("  agent <- agents[agents$id == agent_id, ]\n")
cat("  mu_base <- agent$mu_base\n")
cat("  \n")
cat("  # Fatigue (max -30%)\n")
cat("  heures <- as.numeric(difftime(t, '08:00', units='hours'))\n")
cat("  fatigue <- min(0.3, 0.02 * heures)\n")
cat("  \n")
cat("  # Apprentissage (max +10%)\n")
cat("  apprentissage <- 0.1 * log(1 + nb_traites/10)\n")
cat("  \n")
cat("  mu <- mu_base * (1 - fatigue + apprentissage)\n")
cat("  return(mu)\n")
cat("}\n\n")
cat("# Simulation avec pauses\n")
cat("env %>%\n")
cat("  add_resource('agent_A', capacity=1, mon=TRUE) %>%\n")
cat("  add_resource('agent_B', capacity=1, mon=TRUE) %>%\n")
cat("  add_resource('agent_C', capacity=1, mon=TRUE) %>%\n")
cat("  \n")
cat("  # Programmer les pauses\n")
cat("  add_generator('pause_A_1', trajectory() %>%\n")
cat("    seize('agent_A', amount=-1) %>%      # Rendre indisponible\n")
cat("    timeout(15*60) %>%\n")
cat("    release('agent_A', amount=-1),       # Rendre disponible\n")
cat("    at(630)  # 10h30 = 630 min depuis 00h00\n")
cat("  )\n")
cat("```\n\n")

cat("BÉNÉFICES:\n")
cat("  ✓ Capture l'HÉTÉROGÉNÉITÉ réelle du personnel\n")
cat("  ✓ Permet d'optimiser les plannings de pauses\n")
cat("  ✓ Évalue impact de la formation (amélioration μ)\n")
cat("  ✓ Modélise réalisme des pics de charge (pauses simultanées)\n")
cat("  ✓ Utile pour gestion RH: besoins en compétences\n\n")

cat("RISQUES:\n")
cat("  ✗ EXPLOSION de complexité: N agents × M propriétés\n")
cat("  ✗ Données RH souvent confidentielles ou indisponibles\n")
cat("  ✗ Difficile de mesurer 'compétence' objectivement\n")
cat("  ✗ Hypothèses sur fatigue/apprentissage non validées\n")
cat("  ✗ Risque de biais: modèle peut stigmatiser certains agents\n")
cat("  ✗ Éthique: acceptabilité de modéliser performance individuelle\n\n")

cat("DONNÉES NÉCESSAIRES:\n")
cat("  - Temps de service PAR agent (analyse secondaire des données)\n")
cat("  - Planning de travail et pauses (RH)\n")
cat("  - Ancienneté, formation, certifications\n")
cat("  - Évaluation objective de performance (si éthiquement acceptable)\n\n")

# ========== PARTIE 3 : TABLEAU RÉCAPITULATIF ==========
cat("\n\n")
cat(strrep("-", 80), "\n")
cat("PARTIE 3 : TABLEAU RÉCAPITULATIF BÉNÉFICES/RISQUES\n")
cat(strrep("-", 80), "\n\n")

recapitulatif <- data.frame(
  Amelioration = c(
    "1. Décomposition service",
    "2. Arrivées réalistes",
    "3. Non-stationnarité fine",
    "4. Comportement patients",
    "5. Ressources hétérogènes"
  ),
  Gain_precision = c(
    "+++", "+++", "++", "+", "++"
  ),
  Complexite_implementation = c(
    "++", "+++", "++", "+++", "++++"
  ),
  Besoin_donnees = c(
    "+++", "++++", "++++", "+++++", "++++"
  ),
  Risque_overfitting = c(
    "++", "+", "++++", "++", "+++"
  ),
  Temps_calcul = c(
    "+", "+", "++", "+", "+++"
  ),
  Priorite_recommandee = c(
    "HAUTE", "HAUTE", "MOYENNE", "BASSE", "MOYENNE"
  )
)

cat("Légende: + (faible) à +++++ (très élevé)\n\n")
print(kable(recapitulatif, format = "simple"))

# ========== PARTIE 4 : STRATÉGIE DE MISE EN ŒUVRE ==========
cat("\n\n")
cat(strrep("-", 80), "\n")
cat("PARTIE 4 : STRATÉGIE DE MISE EN ŒUVRE RECOMMANDÉE\n")
cat(strrep("-", 80), "\n\n")

cat("APPROCHE PAR PHASES:\n\n")

cat("PHASE 1 - FONDATIONS (Priorité HAUTE):\n")
cat("  1.1 Collecte de données enrichies:\n")
cat("      - Au moins 20-30 jours similaires (même période année)\n")
cat("      - Planning des RDV + arrivées réelles\n")
cat("      - Chronométrage détaillé d'au moins 100 services complets\n")
cat("  \n")
cat("  1.2 Amélioration du processus d'arrivée:\n")
cat("      - Implémenter modèle hybride (RDV + spontanés)\n")
cat("      - Estimer taux de no-show\n")
cat("      - Valider sur jours test\n")
cat("  \n")
cat("  1.3 Décomposition des temps de service:\n")
cat("      - Identifier 5-7 micro-étapes principales\n")
cat("      - Chronométrer chaque étape (n≥30)\n")
cat("      - Ajuster distributions (tests de Kolmogorov-Smirnov)\n\n")

cat("PHASE 2 - RAFFINEMENT (Priorité MOYENNE):\n")
cat("  2.1 Modèle non-stationnaire:\n")
cat("      - Découper en tranches de 30-60 min\n")
cat("      - Estimer λ(t) et μ(t) par tranche\n")
cat("      - Validation croisée sur jours non utilisés\n")
cat("  \n")
cat("  2.2 Ressources hétérogènes (si pertinent):\n")
cat("      - Analyser variance inter-agents des temps de service\n")
cat("      - Si CV > 0.3 entre agents → modéliser hétérogénéité\n")
cat("      - Sinon, garder modèle homogène\n\n")

cat("PHASE 3 - AVANCÉE (Priorité BASSE, optionnel):\n")
cat("  3.1 Comportement patients:\n")
cat("      - Seulement si taux d'abandon observé > 5%\n")
cat("      - Questionnaires de satisfaction pour calibrer patience\n")
cat("      - Expérimentation contrôlée pour valider hypothèses\n")
cat("  \n")
cat("  3.2 Optimisation:\n")
cat("      - Une fois modèle validé, l'utiliser pour:\n")
cat("        * Optimisation planning RDV\n")
cat("        * Dimensionnement ressources\n")
cat("        * Gestion pauses personnel\n\n")

cat("CRITÈRES D'ARRÊT (éviter sur-modélisation):\n")
cat("  ✓ Amélioration < 5% sur métriques clés → STOP\n")
cat("  ✓ R² validation < 0.7 → modèle trop complexe → SIMPLIFIER\n")
cat("  ✓ Temps calcul > 1h pour 1 jour simulé → trop lourd → OPTIMISER\n")
cat("  ✓ >50 paramètres à calibrer → risque overfitting → RÉDUIRE\n\n")

# ========== PARTIE 5 : OUTILS ET TECHNOLOGIES ==========
cat("\n")
cat(strrep("-", 80), "\n")
cat("PARTIE 5 : OUTILS ET TECHNOLOGIES RECOMMANDÉS\n")
cat(strrep("-", 80), "\n\n")

cat("SIMULATION À ÉVÉNEMENTS DISCRETS (DES):\n")
cat("  • simmer (R): Léger, intégration R facile, bon pour prototypage\n")
cat("    + Avantages: Gratuit, scripting flexible, packages stats R\n")
cat("    - Limites: Performance limitée (>1M événements), pas de GUI\n")
cat("  \n")
cat("  • SimPy (Python): Similaire à simmer, écosystème Python\n")
cat("    + Avantages: Gratuit, ML/AI facile (scikit-learn, TensorFlow)\n")
cat("    - Limites: Courbe apprentissage si pas familier Python\n")
cat("  \n")
cat("  • AnyLogic: Logiciel commercial, GUI drag-and-drop\n")
cat("    + Avantages: Visualisation 3D, animations, reporting auto\n")
cat("    - Limites: Coûteux (€€€), moins flexible que code\n")
cat("  \n")
cat("  • Arena (Rockwell): Standard industrie, robuste\n")
cat("    + Avantages: Mature, nombreuses features, support\n")
cat("    - Limites: Très coûteux, courbe apprentissage raide\n\n")

cat("RECOMMANDATION:\n")
cat("  → Commencer avec simmer (R) pour prototypage rapide\n")
cat("  → Si besoin de visualisation/reporting → AnyLogic\n")
cat("  → Si intégration ML/optimisation → SimPy (Python)\n\n")

cat("VALIDATION ET ANALYSE:\n")
cat("  • Validation: KPI empiriques vs simulés (RMSE, MAPE)\n")
cat("  • Analyse de sensibilité: package sensitivity (R)\n")
cat("  • Optimisation: optimisation stochastique (CMA-ES, genetic algorithms)\n")
cat("  • Visualisation: ggplot2, plotly, Shiny (dashboards interactifs)\n\n")

# ========== PARTIE 6 : MÉTRIQUES DE VALIDATION ==========
cat("\n")
cat(strrep("-", 80), "\n")
cat("PARTIE 6 : VALIDATION DU MODÈLE AMÉLIORÉ\n")
cat(strrep("-", 80), "\n\n")

cat("MÉTRIQUES DE VALIDATION QUANTITATIVE:\n\n")

cat("1. ERREUR SUR TEMPS D'ATTENTE:\n")
cat("   MAPE(W_q) = Mean Absolute Percentage Error\n")
cat("   = (1/n) Σ |W_q_simulé - W_q_empirique| / W_q_empirique\n")
cat("   \n")
cat("   Seuils acceptables:\n")
cat("     - MAPE < 10% : EXCELLENT\n")
cat("     - MAPE < 20% : BON\n")
cat("     - MAPE < 30% : ACCEPTABLE\n")
cat("     - MAPE > 30% : REVOIR MODÈLE\n\n")

cat("2. ERREUR SUR OCCUPATION:\n")
cat("   RMSE(L) = Root Mean Square Error\n")
cat("   = √[(1/n) Σ (L_simulé - L_empirique)²]\n")
cat("   \n")
cat("   Seuil: RMSE(L) < 0.5 patients\n\n")

cat("3. DISTRIBUTION DES TEMPS:\n")
cat("   Test de Kolmogorov-Smirnov:\n")
cat("   H0: F_simulé = F_empirique\n")
cat("   → p-value > 0.05 pour accepter similarité\n\n")

cat("4. VALIDATION CROISÉE:\n")
cat("   - Calibrer sur 70% jours\n")
cat("   - Tester sur 30% jours restants\n")
cat("   - Si performance validation << calibration → overfitting\n\n")

cat("MÉTRIQUES QUALITATIVES:\n")
cat("  ✓ Plausibilité: les résultats 'font sens' pour les experts métier\n")
cat("  ✓ Robustesse: petites variations paramètres → petites variations résultats\n")
cat("  ✓ Interprétabilité: stakeholders comprennent le modèle\n")
cat("  ✓ Utilisabilité: temps calcul raisonnable, interface accessible\n\n")

# ========== CONCLUSION ==========
cat("\n\n")
cat(strrep("=", 80), "\n")
cat("CONCLUSION\n")
cat(strrep("=", 80), "\n\n")

cat("SYNTHÈSE:\n")
cat("Les modèles analytiques de files d'attente (M/M/c, M/G/c) sont d'excellents\n")
cat("outils pour une première analyse rapide. Cependant, pour un service hospitalier\n")
cat("réel, de nombreuses simplifications limitent leur précision.\n\n")

cat("Les 5 améliorations proposées permettent de construire un modèle de simulation\n")
cat("beaucoup plus fidèle à la réalité:\n")
cat("  1. Décomposition détaillée des services → identifier goulots\n")
cat("  2. Processus d'arrivée réaliste → capturer RDV et variations\n")
cat("  3. Non-stationnarité fine → modéliser pics horaires\n")
cat("  4. Comportement patients → prendre en compte abandons\n")
cat("  5. Ressources hétérogènes → refléter compétences variées\n\n")

cat("RECOMMANDATION FINALE:\n")
cat("→ Approche PROGRESSIVE et PRAGMATIQUE:\n")
cat("  • Commencer simple (améliorations 1-2)\n")
cat("  • Valider à chaque étape\n")
cat("  • Ajouter complexité SEULEMENT si gain mesurable\n")
cat("  • TOUJOURS privilégier interprétabilité sur précision marginale\n\n")

cat("BALANCE BÉNÉFICES/RISQUES:\n")
cat("  ✓ Un modèle légèrement imprécis mais compris et utilisé\n")
cat("    vaut MIEUX qu'un\n")
cat("  ✗ modèle très précis mais incompréhensible et inutilisé\n\n")

cat("Le modèle PARFAIT n'existe pas.\n")
cat("L'objectif est un modèle UTILE pour la prise de décision.\n\n")

cat(strrep("=", 80), "\n\n")
```
